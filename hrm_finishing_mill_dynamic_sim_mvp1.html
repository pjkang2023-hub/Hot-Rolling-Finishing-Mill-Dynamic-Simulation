<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finishing Mill Simulator - Electrical Steel</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Rajdhani:wght@400;500;600;700&display=swap');
        
        :root {
            /* White Theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-panel: #ffffff;
            --bg-card: #f8f9fa;
            --bg-tertiary: #f0f2f5;
            --border-color: #d0d7de;
            --text-primary: #1f2328;
            --text-secondary: #57606a;
            --text-muted: #8b949e;
            --accent-blue: #0969da;
            --accent-green: #1a7f37;
            --accent-yellow: #9a6700;
            --accent-orange: #bc4c00;
            --accent-red: #cf222e;
            --accent-purple: #8250df;
            --accent-cyan: #0891b2;
            --glow-blue: rgba(9, 105, 218, 0.15);
            --glow-green: rgba(26, 127, 55, 0.15);
            --glow-red: rgba(207, 34, 46, 0.15);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-rows: auto 1fr auto;
            min-height: 100vh;
        }
        
        /* Header */
        .header {
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-title {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .logo {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 18px;
            color: white;
        }
        
        .header h1 {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        .header-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .sim-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-panel);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s infinite;
        }
        
        .status-indicator.stopped {
            background: var(--accent-red);
            animation: none;
        }
        
        .status-indicator.paused {
            background: var(--accent-yellow);
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(63, 185, 80, 0.7); }
            50% { opacity: 0.8; box-shadow: 0 0 0 6px rgba(63, 185, 80, 0); }
        }
        
        .btn {
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 14px;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
            color: var(--bg-primary);
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.3);
        }
        
        .btn-danger {
            background: var(--accent-red);
            color: white;
        }
        
        .btn-warning {
            background: var(--accent-yellow);
            color: white;
        }
        
        .btn-secondary {
            background: var(--bg-panel);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        /* Main Layout - New Tabbed Design */
        .main-content {
            display: flex;
            flex-direction: column;
            padding: 16px;
            gap: 16px;
            overflow: hidden;
        }
        
        /* Main Tab Navigation */
        .main-tabs {
            display: flex;
            gap: 4px;
            background: var(--bg-secondary);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .main-tab {
            padding: 12px 24px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .main-tab:hover {
            background: var(--bg-panel);
            color: var(--text-secondary);
        }
        
        .main-tab.active {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
            color: white;
        }
        
        .main-tab-icon {
            font-size: 16px;
        }
        
        /* Tab Content Panels */
        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
        }
        
        .tab-content.active {
            display: flex;
            gap: 16px;
        }
        
        /* Tab-specific layouts */
        .tab-content.overview-tab {
            flex-direction: column;
        }
        
        .tab-content.setup-tab {
            flex-direction: row;
        }
        
        .tab-content.control-tab {
            flex-direction: row;
        }
        
        .tab-content.cooling-tab {
            flex-direction: row;
        }
        
        .tab-content.optimize-tab {
            flex-direction: row;
        }
        
        .tab-content.trends-tab {
            flex-direction: column;
            padding: 8px;
        }
        
        .trends-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 8px;
            height: 100%;
        }
        
        .trend-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .trend-panel .panel-header {
            padding: 8px 12px;
            flex-shrink: 0;
        }
        
        .trend-panel .panel-content {
            flex: 1;
            padding: 8px;
            min-height: 0;
        }
        
        .trend-canvas-small {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .trend-legend {
            display: flex;
            gap: 8px;
            font-size: 9px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .legend-color {
            width: 12px;
            height: 3px;
            border-radius: 1px;
        }
        
        /* Layout helpers */
        .flex-row {
            display: flex;
            gap: 16px;
            flex: 1;
        }
        
        .flex-col {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .flex-1 {
            flex: 1;
        }
        
        .flex-2 {
            flex: 2;
        }
        
        .flex-3 {
            flex: 3;
        }
        
        /* Panels */
        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel.compact {
            max-height: 400px;
        }
        
        .panel-header {
            background: var(--bg-secondary);
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .panel-title {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
        }
        
        .panel-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }
        
        .panel-content.no-scroll {
            overflow: hidden;
        }
        
        /* Card grid for overview */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }
        
        .card-grid-3 {
            grid-template-columns: repeat(3, 1fr);
        }
        
        .card-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }
        
        /* Schedule Table */
        .schedule-table-container {
            margin-top: 12px;
        }
        
        .schedule-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .schedule-table th {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            padding: 8px 6px;
            text-align: center;
            font-weight: 500;
            border-bottom: 2px solid var(--border-color);
            white-space: nowrap;
        }
        
        .schedule-table th small {
            display: block;
            font-size: 9px;
            color: var(--text-muted);
            font-weight: 400;
        }
        
        .schedule-table td {
            padding: 6px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .schedule-table tr:hover {
            background: var(--bg-secondary);
        }
        
        .schedule-table .stand-col {
            font-weight: 600;
            color: var(--accent-cyan);
        }
        
        /* Mini table for control tab */
        .stands-status-table {
            max-height: 180px;
            overflow-y: auto;
            margin-bottom: 8px;
        }
        
        .mini-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 10px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .mini-table th {
            background: var(--bg-secondary);
            color: var(--text-muted);
            padding: 4px 3px;
            text-align: center;
            font-weight: 500;
            font-size: 9px;
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
        }
        
        .mini-table th small {
            display: block;
            font-size: 8px;
            color: var(--text-muted);
            font-weight: 400;
        }
        
        .mini-table td {
            padding: 3px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .mini-table tr.active {
            background: var(--bg-secondary);
        }
        
        .mini-table .stand-col {
            font-weight: 600;
            color: var(--accent-cyan);
        }
        
        /* Status cards */
        .status-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .status-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-card-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
        }
        
        .status-card-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 28px;
            font-weight: 600;
            color: var(--accent-cyan);
        }
        
        .status-card-value.success {
            color: var(--accent-green);
        }
        
        .status-card-value.warning {
            color: var(--accent-yellow);
        }
        
        .status-card-value.danger {
            color: var(--accent-red);
        }
        
        .status-card-unit {
            font-size: 14px;
            color: var(--text-muted);
            margin-left: 4px;
        }
        
        .status-card-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* Mill Visualization - Larger */
        .mill-visualization {
            flex: 1;
            min-height: 350px;
            position: relative;
        }
        
        .mill-visualization.large {
            min-height: 450px;
        }
        
        .mill-canvas-container {
            width: 100%;
            height: 100%;
            min-height: 320px;
            position: relative;
        }
        
        #millCanvas {
            width: 100%;
            height: 100%;
            min-height: 320px;
            display: block;
        }
        
        /* Form Styles */
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-group:last-child {
            margin-bottom: 0;
        }
        
        .form-label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }
        
        .form-select, .form-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            transition: border-color 0.2s;
        }
        
        .form-select:focus, .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .form-row-3 {
            grid-template-columns: 1fr 1fr 1fr;
        }
        
        .form-row-4 {
            grid-template-columns: 1fr 1fr 1fr 1fr;
        }
        
        .input-unit {
            position: relative;
        }
        
        .input-unit .form-input {
            padding-right: 40px;
        }
        
        .input-unit .unit {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Stand Cards - Updated for new layout */
        .stands-overview {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 12px;
        }
        
        .stands-overview.compact {
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
        }
        
        .stand-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s;
            cursor: pointer;
            min-width: 140px;
        }
        
        .stand-card:hover {
            border-color: var(--accent-blue);
            background: var(--bg-panel);
            transform: translateY(-2px);
        }
        
        .stand-card.active {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 16px var(--glow-blue);
        }
        
        .stand-card.alarm {
            border-color: var(--accent-red);
            box-shadow: 0 0 16px var(--glow-red);
        }
        
        .stand-header {
            text-align: center;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .stand-name {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent-cyan);
        }
        
        .stand-data-grid {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .stand-data-row {
            display: grid;
            grid-template-columns: 60px 1fr 28px;
            align-items: center;
            font-size: 11px;
            gap: 4px;
        }
        
        .stand-data-label {
            color: var(--text-muted);
            text-align: left;
        }
        
        .stand-data-value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
            text-align: right;
            font-weight: 500;
        }
        
        .stand-data-unit {
            color: var(--text-muted);
            font-size: 10px;
            text-align: left;
        }
        
        .stand-number {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stand-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-weight: 500;
        }
        
        .stand-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        .stand-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }
        
        .stand-stat {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }
        
        .stand-stat-label {
            color: var(--text-muted);
        }
        
        .stand-stat-value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
        }
        
        /* Data Display */
        .data-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .data-row:last-child {
            border-bottom: none;
        }
        
        .data-label {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .data-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 500;
            color: var(--accent-cyan);
        }
        
        .data-value.warning {
            color: var(--accent-yellow);
        }
        
        .data-value.danger {
            color: var(--accent-red);
        }
        
        .data-value.success {
            color: var(--accent-green);
        }
        
        /* Charts - Larger for trends tab */
        .chart-container {
            height: 300px;
            position: relative;
        }
        
        .chart-container.large {
            height: 400px;
        }
        
        /* Gauges - Updated for better visibility */
        .gauge-container {
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            justify-content: center;
            padding: 16px;
        }
        
        .gauge-container.horizontal {
            flex-wrap: nowrap;
            justify-content: space-around;
        }
        
        .gauge {
            width: 120px;
            height: 120px;
            position: relative;
        }
        
        .gauge.large {
            width: 150px;
            height: 150px;
        }
        
        .gauge svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        
        .gauge-bg {
            fill: none;
            stroke: var(--bg-secondary);
            stroke-width: 8;
        }
        
        .gauge-fill {
            fill: none;
            stroke: var(--accent-cyan);
            stroke-width: 8;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }
        
        .gauge-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .gauge-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-weight: 600;
        }
        
        .gauge.large .gauge-value {
            font-size: 26px;
        }
        
        .gauge-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        .gauge-title {
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 8px;
        }
        
        /* Control Groups */
        .control-section {
            margin-bottom: 20px;
        }
        
        .control-section:last-child {
            margin-bottom: 0;
        }
        
        .control-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-blue);
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-color);
        }
        
        /* Sliders */
        .slider-group {
            margin-bottom: 16px;
        }
        
        .slider-group:last-child {
            margin-bottom: 0;
        }
        
        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .slider-label {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .slider-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--accent-cyan);
            font-weight: 500;
        }
        
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--bg-secondary);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }
        
        /* Toggle Switches */
        .toggle-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .toggle-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: var(--bg-card);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .toggle-label {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .toggle {
            position: relative;
            width: 44px;
            height: 24px;
            flex-shrink: 0;
        }
        
        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            transition: 0.3s;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background: var(--text-muted);
            border-radius: 50%;
            transition: 0.3s;
        }
        
        .toggle input:checked + .toggle-slider {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }
        
        .toggle input:checked + .toggle-slider:before {
            transform: translateX(20px);
            background: white;
        }
        
        /* Footer */
        .footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 8px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .footer-stats {
            display: flex;
            gap: 32px;
        }
        
        .footer-stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .footer-stat-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .footer-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--accent-cyan);
        }
        
        .footer-actions {
            display: flex;
            gap: 12px;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
        }
        
        .tab {
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .tab:hover {
            background: var(--bg-secondary);
            color: var(--text-secondary);
        }
        
        .tab.active {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }
        
        /* Trend Chart - Larger */
        .trend-canvas {
            width: 100%;
            height: 250px;
            background: var(--bg-secondary);
            border-radius: 6px;
        }
        
        .trend-canvas.large {
            height: 350px;
        }
        
        .trend-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .trend-controls .form-select {
            width: auto;
            min-width: 150px;
        }
        
        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            padding: 16px 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 16px;
            font-weight: 600;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }
        
        .modal-close:hover {
            color: var(--text-primary);
        }
        
        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
        }
        
        /* Looper Animation */
        .looper-display {
            display: flex;
            justify-content: space-around;
            margin: 16px 0;
        }
        
        .looper-item {
            text-align: center;
        }
        
        .looper-visual {
            width: 60px;
            height: 40px;
            position: relative;
            margin: 0 auto 8px;
        }
        
        .looper-arm {
            width: 4px;
            height: 30px;
            background: var(--accent-cyan);
            position: absolute;
            bottom: 0;
            left: 50%;
            transform-origin: bottom center;
            transition: transform 0.3s ease;
            border-radius: 2px;
        }
        
        .looper-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }
        
        .looper-tension {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--accent-cyan);
        }
        
        /* Progress bar */
        .progress-bar {
            height: 4px;
            background: var(--bg-secondary);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
            transition: width 0.3s ease;
        }
        
        /* Cooling Zones - Updated layout */
        .cooling-zones {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 16px;
        }
        
        .cooling-zones.vertical {
            grid-template-columns: 1fr;
            gap: 8px;
        }
        
        .cooling-zone {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .cooling-zones.vertical .cooling-zone {
            display: grid;
            grid-template-columns: 60px 1fr 50px;
            align-items: center;
            padding: 10px 16px;
        }
        
        .cooling-zone-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .cooling-zone-stats {
            font-size: 10px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .cooling-zone-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .cooling-zone-name {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
        }
        
        .cooling-zone-slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--accent-blue) 0%, var(--accent-cyan) 50%, var(--accent-green) 100%);
            outline: none;
            -webkit-appearance: none;
        }
        
        .cooling-zone-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .cooling-zone-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: var(--accent-cyan);
            text-align: center;
            font-weight: 500;
        }
        
        .cooling-zone-stats {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--text-muted);
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }
        
        /* Optimization Animation */
        @keyframes optimizing {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .optimizing .progress-fill {
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple), var(--accent-cyan), var(--accent-blue));
            background-size: 200% 100%;
            animation: optimizing 1.5s ease infinite;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        /* Responsive */
        @media (max-width: 1400px) {
            .stands-overview {
                grid-template-columns: repeat(7, 1fr);
                gap: 8px;
            }
            
            .cooling-zones {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .card-grid-4 {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 1200px) {
            .main-tabs {
                flex-wrap: wrap;
            }
            
            .main-tab {
                padding: 10px 16px;
                font-size: 12px;
            }
            
            .stands-overview {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .cooling-zones {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .toggle-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .main-tabs {
                overflow-x: auto;
                flex-wrap: nowrap;
            }
            
            .main-tab-text {
                display: none;
            }
            
            .stands-overview {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .cooling-zones {
                grid-template-columns: 1fr;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-title">
                <div class="logo">FM</div>
                <div>
                    <h1>Finishing Mill Simulator</h1>
                    <div class="header-subtitle">7-Stand Hot Rolling ‚Ä¢ Electrical Steel</div>
                </div>
            </div>
            <div class="header-controls">
                <div class="sim-status">
                    <div class="status-indicator stopped" id="statusIndicator"></div>
                    <span id="statusText">STOPPED</span>
                </div>
                <button class="btn btn-primary" id="btnStart" onclick="startSimulation()">‚ñ∂ Start</button>
                <button class="btn btn-warning" id="btnPause" onclick="pauseSimulation()" style="display:none;">‚è∏ Pause</button>
                <button class="btn btn-danger" id="btnStop" onclick="stopSimulation()" style="display:none;">‚èπ Stop</button>
                <button class="btn btn-secondary" onclick="resetSimulation()">‚Ü∫ Reset</button>
                <button class="btn btn-secondary" onclick="exportData()">‚¨á Export</button>
            </div>
        </header>
        
        <!-- Main Content -->
        <main class="main-content">
            <!-- Main Tab Navigation -->
            <nav class="main-tabs">
                <button class="main-tab active" onclick="switchMainTab('overview')">
                    <span class="main-tab-icon">üìä</span>
                    <span class="main-tab-text">Overview</span>
                </button>
                <button class="main-tab" onclick="switchMainTab('setup')">
                    <span class="main-tab-icon">‚öôÔ∏è</span>
                    <span class="main-tab-text">Setup</span>
                </button>
                <button class="main-tab" onclick="switchMainTab('control')">
                    <span class="main-tab-icon">üéõÔ∏è</span>
                    <span class="main-tab-text">Control</span>
                </button>
                <button class="main-tab" onclick="switchMainTab('cooling')">
                    <span class="main-tab-icon">üíß</span>
                    <span class="main-tab-text">Cooling</span>
                </button>
                <button class="main-tab" onclick="switchMainTab('trends')">
                    <span class="main-tab-icon">üìà</span>
                    <span class="main-tab-text">Trends</span>
                </button>
            </nav>
            
            <!-- ==================== OVERVIEW TAB ==================== -->
            <div class="tab-content overview-tab active" id="tab-overview">
                <!-- Status Cards Row -->
                <div class="card-grid card-grid-4">
                    <div class="status-card">
                        <div class="status-card-header">
                            <span class="status-card-title">Exit Thickness</span>
                        </div>
                        <div>
                            <span class="status-card-value" id="currentThickness">--</span>
                            <span class="status-card-unit">mm</span>
                        </div>
                        <div class="status-card-subtitle">Target: <span id="targetThicknessDisplay">2.00</span> mm</div>
                    </div>
                    <div class="status-card">
                        <div class="status-card-header">
                            <span class="status-card-title">Exit Temperature</span>
                        </div>
                        <div>
                            <span class="status-card-value" id="currentTemp">--</span>
                            <span class="status-card-unit">¬∞C</span>
                        </div>
                        <div class="status-card-subtitle">Target FDT: <span id="targetFDTDisplay">880</span>¬∞C</div>
                    </div>
                    <div class="status-card">
                        <div class="status-card-header">
                            <span class="status-card-title">F7 Speed</span>
                        </div>
                        <div>
                            <span class="status-card-value" id="currentSpeed">0.0</span>
                            <span class="status-card-unit">m/s</span>
                        </div>
                        <div class="status-card-subtitle">Strip Position: <span id="stripPosition">0.0</span> m</div>
                    </div>
                    <div class="status-card">
                        <div class="status-card-header">
                            <span class="status-card-title">Thickness Dev</span>
                        </div>
                        <div>
                            <span class="status-card-value" id="thicknessDev">¬±0.000</span>
                            <span class="status-card-unit">mm</span>
                        </div>
                        <div class="status-card-subtitle">Crown: <span id="currentCrown">0</span> ¬µm</div>
                    </div>
                </div>
                
                <!-- Mill Visualization -->
                <div class="panel" style="flex: 2; min-height: 380px;">
                    <div class="panel-header">
                        <span class="panel-title">Mill Overview</span>
                        <div class="tabs">
                            <button class="tab active" onclick="setView('schematic')">Schematic</button>
                            <button class="tab" onclick="setView('profile')">Profile</button>
                            <button class="tab" onclick="setView('temperature')">Temperature</button>
                        </div>
                    </div>
                    <div class="mill-canvas-container">
                        <canvas id="millCanvas"></canvas>
                    </div>
                </div>
                
                <!-- Stands Overview -->
                <div class="panel">
                    <div class="panel-header">
                        <span class="panel-title">Stand Parameters</span>
                    </div>
                    <div class="panel-content">
                        <div class="stands-overview" id="standsOverview">
                            <!-- Generated by JS -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ==================== SETUP TAB ==================== -->
            <div class="tab-content setup-tab" id="tab-setup">
                <!-- Material & Dimensions -->
                <div class="panel flex-1">
                    <div class="panel-header">
                        <span class="panel-title">Material & Dimensions</span>
                    </div>
                    <div class="panel-content">
                        <div class="form-row" style="margin-bottom: 20px;">
                            <div class="form-group">
                                <label class="form-label">Steel Type</label>
                                <select class="form-select" id="steelType" onchange="updateMaterialParams()">
                                    <option value="NO">Non-Oriented (NO)</option>
                                    <option value="GO">Grain-Oriented (GO)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Grade</label>
                                <select class="form-select" id="steelGrade" onchange="updateMaterialParams()">
                                    <optgroup label="Non-Oriented Normal">
                                        <option value="50W800" selected>50W800 (Si: 0.5%)</option>
                                        <option value="50W600">50W600 (Si: 1.0%)</option>
                                        <option value="50W470">50W470 (Si: 1.5%)</option>
                                    </optgroup>
                                    <optgroup label="Non-Oriented High">
                                        <option value="35W360">35W360 (Si: 2.0%)</option>
                                        <option value="35W300">35W300 (Si: 2.5%)</option>
                                        <option value="35W270">35W270 (Si: 2.8%)</option>
                                    </optgroup>
                                    <optgroup label="Non-Oriented Premium">
                                        <option value="30W250">30W250 (Si: 3.0%)</option>
                                        <option value="27W230">27W230 (Si: 3.2%)</option>
                                        <option value="23W200">23W200 (Si: 3.5%)</option>
                                    </optgroup>
                                </select>
                            </div>
                        </div>
                        
                        <div class="control-section">
                            <div class="control-section-title">Strip Dimensions</div>
                            <div class="form-row" style="margin-bottom: 16px;">
                                <div class="form-group input-unit">
                                    <label class="form-label">Entry Thickness</label>
                                    <input type="number" class="form-input" id="entryThickness" value="32" step="0.1">
                                    <span class="unit">mm</span>
                                </div>
                                <div class="form-group input-unit">
                                    <label class="form-label">Target Exit</label>
                                    <input type="number" class="form-input" id="exitThickness" value="2.0" step="0.01">
                                    <span class="unit">mm</span>
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group input-unit">
                                    <label class="form-label">Width</label>
                                    <input type="number" class="form-input" id="stripWidth" value="1250" step="10">
                                    <span class="unit">mm</span>
                                </div>
                                <div class="form-group input-unit">
                                    <label class="form-label">Entry Temp</label>
                                    <input type="number" class="form-input" id="entryTemp" value="1050" step="5">
                                    <span class="unit">¬∞C</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="control-section">
                            <div class="control-section-title">Schedule Calculation</div>
                            <div class="form-row" style="margin-bottom: 12px;">
                                <div class="form-group">
                                    <label class="form-label">Method</label>
                                    <select class="form-select" id="calcMethod">
                                        <option value="quick">Quick Calculate</option>
                                        <option value="hybrid" selected>Optimized (Hybrid)</option>
                                        <option value="analytical">Optimized (Analytical)</option>
                                        <option value="gradient">Optimized (Gradient)</option>
                                        <option value="genetic">Optimized (Genetic)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Objective</label>
                                    <select class="form-select" id="optimObjective">
                                        <option value="balanced" selected>Balanced</option>
                                        <option value="quality">Quality Focus</option>
                                        <option value="productivity">Productivity</option>
                                        <option value="energy">Energy Saving</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- FDT Control Options -->
                            <div class="control-section-title" style="margin-top: 12px;">FDT Control</div>
                            <div class="toggle-grid" style="gap: 8px;">
                                <div class="toggle-group">
                                    <span class="toggle-label">Speed Optimization</span>
                                    <label class="toggle">
                                        <input type="checkbox" id="enableSpeedOpt" checked>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                <div class="toggle-group">
                                    <span class="toggle-label">Spray Optimization</span>
                                    <label class="toggle">
                                        <input type="checkbox" id="enableSprayOpt" checked>
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                            </div>
                            <div class="form-row" style="margin-top: 8px;">
                                <div class="form-group">
                                    <label class="form-label">FDT Tolerance (¬∞C)</label>
                                    <input type="number" class="form-input" id="fdtTolerance" value="3" min="1" max="10" step="0.5">
                                </div>
                            </div>
                        </div>
                        
                        <button class="btn btn-primary" style="width: 100%; margin-top: 12px; padding: 14px;" onclick="calculateAndOptimizeSchedule()">
                            ‚ö° Calculate Schedule
                        </button>
                        <div class="progress-bar" style="margin-top: 8px; height: 4px;">
                            <div class="progress-fill" id="optimProgress" style="width: 0%;"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Schedule Preview -->
                <div class="panel flex-1">
                    <div class="panel-header">
                        <span class="panel-title">Rolling Schedule Preview</span>
                    </div>
                    <div class="panel-content">
                        <div class="card-grid" style="margin-bottom: 16px;">
                            <div class="status-card">
                                <div class="status-card-title">Total Reduction</div>
                                <div class="status-card-value" id="totalReduction" style="font-size: 18px;">93.75%</div>
                            </div>
                            <div class="status-card">
                                <div class="status-card-title">Exit Thickness</div>
                                <div class="status-card-value" id="exitThicknessDisplay" style="font-size: 18px;">2.00 mm</div>
                            </div>
                            <div class="status-card">
                                <div class="status-card-title">Total Power</div>
                                <div class="status-card-value" id="estPowerTotal" style="font-size: 18px;">-- MW</div>
                            </div>
                            <div class="status-card">
                                <div class="status-card-title">Exit Temp (FDT)</div>
                                <div class="status-card-value" id="estFDT" style="font-size: 18px;">880¬∞C</div>
                            </div>
                            <div class="status-card">
                                <div class="status-card-title">F7 Speed</div>
                                <div class="status-card-value" id="f7SpeedDisplay" style="font-size: 18px;">-- m/s</div>
                            </div>
                            <div class="status-card">
                                <div class="status-card-title">Avg Spray Flow</div>
                                <div class="status-card-value" id="avgSprayFlow" style="font-size: 18px;">--%</div>
                            </div>
                            <div class="status-card">
                                <div class="status-card-title">Optimization</div>
                                <div class="status-card-value success" id="optimStatus" style="font-size: 18px;">Ready</div>
                            </div>
                            <div class="status-card">
                                <div class="status-card-title">Fitness Score</div>
                                <div class="status-card-value" id="optimFitness" style="font-size: 18px;">--</div>
                            </div>
                        </div>
                        
                        <!-- Schedule Table -->
                        <div class="schedule-table-container" style="overflow-x: auto;">
                            <table class="schedule-table" id="scheduleTable">
                                <thead>
                                    <tr>
                                        <th>Stand</th>
                                        <th>Entry H<br><small>mm</small></th>
                                        <th>Exit H<br><small>mm</small></th>
                                        <th>Red.<br><small>%</small></th>
                                        <th>Force<br><small>MN</small></th>
                                        <th>Torque<br><small>kNm</small></th>
                                        <th>Power<br><small>MW</small></th>
                                        <th>Speed<br><small>m/s</small></th>
                                        <th>Temp<br><small>¬∞C</small></th>
                                        <th>Tension<br><small>B/F MPa</small></th>
                                        <th>Looper<br><small>¬∞</small></th>
                                    </tr>
                                </thead>
                                <tbody id="scheduleTableBody">
                                    <!-- Populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ==================== CONTROL TAB ==================== -->
            <div class="tab-content control-tab" id="tab-control">
                <!-- Control Modes -->
                <div class="panel flex-1">
                    <div class="panel-header">
                        <span class="panel-title">Control Modes</span>
                    </div>
                    <div class="panel-content">
                        <div class="toggle-grid">
                            <div class="toggle-group">
                                <span class="toggle-label">AGC Feedforward</span>
                                <label class="toggle">
                                    <input type="checkbox" id="agcFF" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="toggle-group">
                                <span class="toggle-label">AGC Monitor</span>
                                <label class="toggle">
                                    <input type="checkbox" id="agcMon" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="toggle-group">
                                <span class="toggle-label">Mass Flow AGC</span>
                                <label class="toggle">
                                    <input type="checkbox" id="agcMF" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="toggle-group">
                                <span class="toggle-label">Looper Control</span>
                                <label class="toggle">
                                    <input type="checkbox" id="looperCtrl" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="toggle-group">
                                <span class="toggle-label">Temp Control</span>
                                <label class="toggle">
                                    <input type="checkbox" id="tempCtrl" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="toggle-group">
                                <span class="toggle-label">Crown Control</span>
                                <label class="toggle">
                                    <input type="checkbox" id="crownCtrl" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="control-section" style="margin-top: 24px;">
                            <div class="control-section-title">Inter-Stand Loopers</div>
                            <div class="looper-display" id="looperDisplay">
                                <!-- Generated by JS -->
                            </div>
                        </div>
                        
                        <div class="control-section" style="margin-top: 16px;">
                            <div class="control-section-title">Looper Trends</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <div style="background: var(--bg-secondary); border-radius: 6px; padding: 8px;">
                                    <div style="color: var(--text-secondary); font-size: 11px; margin-bottom: 4px; text-align: center;">Angle (¬∞ vs 25¬∞ setpoint)</div>
                                    <canvas id="looperAngleTrendCanvas" style="width: 100%; height: 180px;"></canvas>
                                </div>
                                <div style="background: var(--bg-secondary); border-radius: 6px; padding: 8px;">
                                    <div style="color: var(--text-secondary); font-size: 11px; margin-bottom: 4px; text-align: center;">Tension (MPa vs setpoint)</div>
                                    <canvas id="looperTensionTrendCanvas" style="width: 100%; height: 180px;"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Stand Control & Shape Parameters -->
                <div class="panel flex-1">
                    <div class="panel-header">
                        <span class="panel-title">All Stands - Control & Shape</span>
                    </div>
                    <div class="panel-content" style="overflow-y: auto;">
                        <div class="control-section">
                            <div class="control-section-title">Gap & Speed Control</div>
                            <div class="stands-status-table">
                                <table class="mini-table" id="gapControlTable">
                                    <thead>
                                        <tr>
                                            <th>Stand</th>
                                            <th>Roll Gap<br><small>mm</small></th>
                                            <th>Exit H<br><small>mm</small></th>
                                            <th>Speed<br><small>m/s</small></th>
                                            <th>Speed Ratio<br><small>vs F7</small></th>
                                        </tr>
                                    </thead>
                                    <tbody id="gapControlBody">
                                        <!-- Generated by JS -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="control-section">
                            <div class="control-section-title">Shape & Crown Control</div>
                            <div class="stands-status-table">
                                <table class="mini-table" id="shapeControlTable">
                                    <thead>
                                        <tr>
                                            <th>Stand</th>
                                            <th>Bending<br><small>kN</small></th>
                                            <th>CVC<br><small>mm</small></th>
                                            <th>Crown<br><small>Œºm (tgt)</small></th>
                                            <th>Flatness<br><small>I-unit</small></th>
                                            <th>Wedge<br><small>Œºm</small></th>
                                        </tr>
                                    </thead>
                                    <tbody id="shapeControlBody">
                                        <!-- Generated by JS -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="control-section">
                            <div class="control-section-title">Force, Torque & Power</div>
                            <div class="stands-status-table">
                                <table class="mini-table" id="standsStatusTable">
                                    <thead>
                                        <tr>
                                            <th>Stand</th>
                                            <th>Force<br><small>MN</small></th>
                                            <th>Torque<br><small>kNm</small></th>
                                            <th>Power<br><small>MW</small></th>
                                            <th>Roll Spd<br><small>m/s</small></th>
                                        </tr>
                                    </thead>
                                    <tbody id="standsStatusBody">
                                        <!-- Generated by JS -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ==================== COOLING TAB ==================== -->
            <div class="tab-content cooling-tab" id="tab-cooling">
                <div class="panel flex-2">
                    <div class="panel-header">
                        <span class="panel-title">Inter-Stand Cooling Zones</span>
                        <div style="display: flex; gap: 12px; align-items: center;">
                            <div class="toggle-group" style="padding: 0; background: none; border: none;">
                                <span class="toggle-label" style="margin-right: 8px;">ISC Auto</span>
                                <label class="toggle">
                                    <input type="checkbox" id="iscAuto">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 11px;" onclick="optimizeCooling()">Optimize</button>
                        </div>
                    </div>
                    <div class="panel-content">
                        <div class="cooling-zones" id="coolingZones">
                            <!-- Generated by JS -->
                        </div>
                        
                        <!-- Zone Temperature Chart -->
                        <div class="control-section" style="margin-top: 16px;">
                            <div class="control-section-title">Zone Temperature Trends</div>
                            <div style="background: var(--bg-secondary); border-radius: 6px; padding: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                    <div style="color: var(--text-secondary); font-size: 11px;">Temperature (¬∞C) - Actual vs Setpoint</div>
                                    <div id="zoneTempLegend" style="display: flex; gap: 8px; font-size: 9px;"></div>
                                </div>
                                <canvas id="zoneTempTrendCanvas" style="width: 100%; height: 220px;"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="panel flex-1">
                    <div class="panel-header">
                        <span class="panel-title">Cooling Summary</span>
                    </div>
                    <div class="panel-content">
                        <div class="status-card" style="margin-bottom: 12px;">
                            <div class="status-card-title">Total Water Flow</div>
                            <div class="status-card-value" id="totalWaterFlow" style="font-size: 24px;">0 L/min</div>
                        </div>
                        <div class="status-card" style="margin-bottom: 12px;">
                            <div class="status-card-title">Total Heat Removed</div>
                            <div class="status-card-value" id="totalHeatRemoved" style="font-size: 24px;">0 MW</div>
                        </div>
                        <div class="status-card" style="margin-bottom: 12px;">
                            <div class="status-card-title">Target FDT</div>
                            <div class="status-card-value" id="targetFDTCooling" style="font-size: 24px;">880¬∞C</div>
                        </div>
                        <div class="status-card" style="margin-bottom: 12px;">
                            <div class="status-card-title">Actual FDT (F7 Exit)</div>
                            <div class="status-card-value" id="actualFDT" style="font-size: 24px;">--¬∞C</div>
                        </div>
                        <div class="status-card" style="margin-bottom: 12px;">
                            <div class="status-card-title">FDT Error</div>
                            <div class="status-card-value" id="fdtError" style="font-size: 24px;">--¬∞C</div>
                        </div>
                        <div class="status-card" style="margin-bottom: 12px;">
                            <div class="status-card-title">Control Mode</div>
                            <div class="status-card-value" id="controlModeDisplay" style="font-size: 14px;">Manual</div>
                        </div>
                        <div class="status-card">
                            <div class="status-card-title">Speed Multiplier</div>
                            <div class="status-card-value" id="speedMultDisplay" style="font-size: 20px;">100%</div>
                        </div>
                    </div>
                </div>
            </div>
            
            
            <!-- ==================== TRENDS TAB ==================== -->
            <div class="tab-content trends-tab" id="tab-trends">
                <div class="trends-grid">
                    <!-- Exit Thickness Trends -->
                    <div class="panel trend-panel">
                        <div class="panel-header">
                            <span class="panel-title">Exit Thickness (mm)</span>
                            <div class="trend-legend" id="thicknessLegend"></div>
                        </div>
                        <div class="panel-content no-scroll">
                            <canvas id="thicknessTrendCanvas" class="trend-canvas-small"></canvas>
                        </div>
                    </div>
                    
                    <!-- Temperature Trends -->
                    <div class="panel trend-panel">
                        <div class="panel-header">
                            <span class="panel-title">Exit Temperature (¬∞C)</span>
                            <div class="trend-legend" id="tempLegend"></div>
                        </div>
                        <div class="panel-content no-scroll">
                            <canvas id="tempTrendCanvas" class="trend-canvas-small"></canvas>
                        </div>
                    </div>
                    
                    <!-- Rolling Force Trends -->
                    <div class="panel trend-panel">
                        <div class="panel-header">
                            <span class="panel-title">Rolling Force (MN)</span>
                            <div class="trend-legend" id="forceLegend"></div>
                        </div>
                        <div class="panel-content no-scroll">
                            <canvas id="forceTrendCanvas" class="trend-canvas-small"></canvas>
                        </div>
                    </div>
                    
                    <!-- Speed Trends -->
                    <div class="panel trend-panel">
                        <div class="panel-header">
                            <span class="panel-title">Strip Speed (m/s)</span>
                            <div class="trend-legend" id="speedLegend"></div>
                        </div>
                        <div class="panel-content no-scroll">
                            <canvas id="speedTrendCanvas" class="trend-canvas-small"></canvas>
                        </div>
                    </div>
                    
                    <!-- Power Trends -->
                    <div class="panel trend-panel">
                        <div class="panel-header">
                            <span class="panel-title">Motor Power (MW)</span>
                            <div class="trend-legend" id="powerLegend"></div>
                        </div>
                        <div class="panel-content no-scroll">
                            <canvas id="powerTrendCanvas" class="trend-canvas-small"></canvas>
                        </div>
                    </div>
                    
                    <!-- Tension Trends -->
                    <div class="panel trend-panel">
                        <div class="panel-header">
                            <span class="panel-title">Inter-Stand Tension (MPa)</span>
                            <div class="trend-legend" id="tensionLegend"></div>
                        </div>
                        <div class="panel-content no-scroll">
                            <canvas id="tensionTrendCanvas" class="trend-canvas-small"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Footer -->
        <footer class="footer">
            <div class="footer-stats">
                <div class="footer-stat">
                    <span class="footer-stat-label">Sim Time</span>
                    <span class="footer-stat-value" id="simTime">00:00.000</span>
                </div>
                <div class="footer-stat">
                    <span class="footer-stat-label">Strip Length</span>
                    <span class="footer-stat-value" id="stripLength">0.0 m</span>
                </div>
                <div class="footer-stat">
                    <span class="footer-stat-label">Coil Progress</span>
                    <span class="footer-stat-value" id="coilProgress">0%</span>
                </div>
                <div class="footer-stat">
                    <span class="footer-stat-label">Frame Rate</span>
                    <span class="footer-stat-value" id="frameRate">60 fps</span>
                </div>
            </div>
            <div class="footer-actions">
                <span style="font-size: 11px; color: var(--text-muted);">v1.0 ‚Ä¢ Digital Twin Ready</span>
            </div>
        </footer>
    </div>
    
    <!-- Stand Configuration Modal -->
    <div class="modal-overlay" id="standModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Stand Configuration</span>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Dynamic content -->
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // FINISHING MILL SIMULATOR - ELECTRICAL STEEL
        // ============================================================
        
        // ============================================================
        // INTER-STAND COOLING SYSTEM
        // ============================================================
        const CoolingSystem = {
            sprays: [],
            
            init: function() {
                // 6 inter-stand cooling zones (between F1-F2 through F6-F7)
                // Calibrated: 0% ‚Üí ~100¬∞C too hot, 50% ‚Üí target, 100% ‚Üí ~50¬∞C too cold
                for (let i = 0; i < 6; i++) {
                    this.sprays.push({
                        id: i + 1,
                        name: `ISC${i + 1}-${i + 2}`,
                        enabled: true,
                        // Spray bank configuration - increased capacity
                        numHeaders: 4,           
                        nozzlesPerHeader: 20,    
                        nozzleFlowRate: 15,      // L/min per nozzle
                        waterTemp: 28,           // ¬∞C
                        // Control parameters
                        flowSetpoint: 50,
                        actualFlow: 50,
                        minFlow: 0,
                        maxFlow: 100,
                        // Spray pattern
                        pattern: 'uniform',
                        edgeMask: 0,
                        // Heat transfer - strong enough for ~15-18¬∞C per zone at 100%
                        // Total capacity ~100¬∞C at full flow across 6 zones
                        heatTransferCoeff: 2500, // W/(m¬≤¬∑K)
                        sprayLength: 450,        // mm
                        // Measured values
                        waterFlow: 0,
                        heatRemoved: 0,
                        tempDrop: 0
                    });
                }
            },
            
            // Calculate heat transfer coefficient based on flow rate
            getHTC: function(sprayIndex, flowPercent) {
                const spray = this.sprays[sprayIndex];
                // HTC varies with water flow rate (approximately sqrt relationship)
                const flowRatio = flowPercent / 100;
                return spray.heatTransferCoeff * Math.sqrt(flowRatio) * (flowRatio > 0.05 ? 1 : 0);
            },
            
            // Calculate cooling effect
            calculateCooling: function(sprayIndex, stripTemp, thickness, width, speed, material) {
                const spray = this.sprays[sprayIndex];
                if (!spray || !spray.enabled || spray.actualFlow < 1) {
                    return { tempDrop: 0, heatRemoved: 0, waterFlow: 0 };
                }
                
                const thermal = MaterialDatabase.getThermalProps(material);
                if (!thermal) {
                    console.warn('No thermal props for material:', material);
                    return { tempDrop: 0, heatRemoved: 0, waterFlow: 0 };
                }
                
                const htc = this.getHTC(sprayIndex, spray.actualFlow);
                
                // Contact time (speed in m/s, sprayLength in mm)
                // Convert sprayLength to meters for proper calculation
                const sprayLength_m = spray.sprayLength / 1000;
                const contactTime = sprayLength_m / speed; // seconds
                
                // Effective cooling area (considering pattern)
                let effectiveWidth = width;
                if (spray.pattern === 'edge') {
                    effectiveWidth = Math.min(200, width * 0.15) * 2;
                } else if (spray.pattern === 'center') {
                    effectiveWidth = width * 0.7;
                }
                effectiveWidth -= spray.edgeMask * 2;
                effectiveWidth = Math.max(0, effectiveWidth);
                
                // Contact area in m¬≤ (width in mm, sprayLength in mm)
                const contactArea = 2 * (effectiveWidth / 1000) * sprayLength_m; // m¬≤, top + bottom
                
                // Heat removed (W)
                const deltaT = stripTemp - spray.waterTemp;
                const heatRate = htc * contactArea * deltaT;
                
                // Mass of strip in cooling zone (all dimensions in mm, convert to m¬≥)
                const volume = (width / 1000) * (thickness / 1000) * sprayLength_m; // m¬≥
                const mass = volume * thermal.rho; // kg
                
                // Temperature drop = Q / (m * Cp)
                // Q = heatRate * contactTime (Joules)
                const heatEnergy = heatRate * contactTime; // Joules
                let tempDrop = heatEnergy / (mass * thermal.Cp);
                
                // Water flow calculation
                const totalNozzles = spray.numHeaders * spray.nozzlesPerHeader;
                const waterFlow = totalNozzles * spray.nozzleFlowRate * (spray.actualFlow / 100);
                
                // Physical limit: can't cool below water temperature
                // At high flows, can achieve up to 25% of temp difference per zone
                const maxPhysicalDrop = Math.max(0, (stripTemp - spray.waterTemp) * 0.25);
                tempDrop = Math.min(tempDrop, maxPhysicalDrop);
                
                return {
                    tempDrop: tempDrop,
                    heatRemoved: heatRate / 1000, // kW
                    waterFlow: waterFlow
                };
            },
            
            // Update spray actuator (with dynamics)
            updateActuator: function(sprayIndex, dt) {
                const spray = this.sprays[sprayIndex];
                // First-order lag for valve dynamics
                const tau = 0.5; // seconds
                const alpha = dt / (tau + dt);
                spray.actualFlow = spray.actualFlow + alpha * (spray.flowSetpoint - spray.actualFlow);
                spray.actualFlow = Math.max(spray.minFlow, Math.min(spray.maxFlow, spray.actualFlow));
            }
        };
        
        // ============================================================
        // SCHEDULE OPTIMIZATION ALGORITHM
        // ============================================================
        const ScheduleOptimizer = {
            // Optimization parameters
            config: {
                maxIterations: 100,
                convergenceTol: 0.001,
                populationSize: 20,  // For genetic algorithm
                mutationRate: 0.15,
                crossoverRate: 0.8,
                eliteCount: 2,
                // FDT control parameters
                enableSpeedOptimization: true,    // Adjust speed to control FDT
                enableSprayOptimization: true,    // Adjust spray cooling to control FDT
                speedIterations: 10,              // Max iterations for speed adjustment
                sprayIterations: 5,               // Max iterations for spray optimization
                fdtTolerance: 3.0                 // ¬∞C tolerance for FDT convergence
            },
            
            // Constraints
            constraints: {
                maxForce: [35, 35, 32, 30, 28, 26, 24],      // MN per stand
                maxReduction: [0.50, 0.45, 0.42, 0.40, 0.38, 0.35, 0.30],
                minReduction: [0.15, 0.12, 0.10, 0.08, 0.06, 0.05, 0.03],
                maxSpeed: 20,        // m/s at F7
                minSpeed: 2,         // m/s at F7
                targetFDT: { min: 850, max: 950 },
                maxTempDrop: 150,    // ¬∞C total through FM
                maxPower: [8, 8, 7.5, 7, 6.5, 6, 5.5],      // MW per stand
                maxCrown: 50,        // ¬µm
                flatnessLimit: 20,   // I-units
                // Spray constraints
                minSprayFlow: 0,     // % of max
                maxSprayFlow: 100,   // % of max
                defaultSprayFlow: 30 // % starting point
            },
            
            // Objective weights
            weights: {
                thickness: 1.0,      // Thickness accuracy
                temperature: 0.8,    // FDT accuracy
                force: 0.3,          // Force balance
                power: 0.4,          // Power consumption
                flatness: 0.6,       // Strip flatness
                productivity: 0.5    // Speed/throughput
            },
            
            // Current best solution
            bestSolution: null,
            bestFitness: Infinity,
            
            // Optimization history
            history: {
                iterations: [],
                fitness: [],
                solutions: []
            },
            
            // Main optimization function
            optimize: function(setup, method = 'hybrid') {
                console.log('Starting schedule optimization...');
                console.log('Setup:', JSON.stringify(setup));
                this.history = { iterations: [], fitness: [], solutions: [] };
                this.bestFitness = Infinity;
                
                // Validate setup
                if (!setup || !setup.material || !setup.entryThickness || !setup.exitThickness) {
                    console.error('Invalid setup:', setup);
                    throw new Error('Invalid optimization setup - missing required fields');
                }
                
                // Get material properties
                const material = setup.material;
                const mat = MaterialDatabase.grades[material];
                if (mat) {
                    this.constraints.targetFDT = mat.targetFDT;
                } else {
                    console.warn('Material not found, using default FDT constraints');
                    this.constraints.targetFDT = { min: 850, max: 950 };
                }
                
                let solution;
                
                switch (method) {
                    case 'analytical':
                        solution = this.analyticalOptimization(setup);
                        break;
                    case 'genetic':
                        solution = this.geneticOptimization(setup);
                        break;
                    case 'gradient':
                        solution = this.gradientOptimization(setup);
                        break;
                    case 'hybrid':
                    default:
                        // Start with analytical, refine with gradient
                        solution = this.analyticalOptimization(setup);
                        solution = this.gradientOptimization(setup, solution);
                        break;
                }
                
                // Apply FDT optimization (speed + spray control)
                solution = this.optimizeFDT(solution, setup);
                
                // Recalculate fitness after FDT optimization
                solution.fitness = this.calculateFitness(solution, setup);
                
                // Re-validate constraints
                const validation = this.validateSolution(solution, setup);
                solution.valid = validation.valid;
                solution.violations = validation.violations;
                
                this.bestSolution = solution;
                console.log('Optimization complete. Best fitness:', this.bestFitness);
                
                return solution;
            },
            
            // Validate solution against all constraints
            validateSolution: function(solution, setup) {
                const numStands = 7;
                let valid = true;
                let violations = [];
                
                // Tolerance values
                const FORCE_TOL = 0.1;
                const POWER_TOL = 0.05;
                const REDUCTION_TOL = 0.002;
                const FDT_TOL = 1.0;
                
                // Check per-stand constraints
                for (let i = 0; i < numStands; i++) {
                    if (solution.forces && solution.forces[i] > this.constraints.maxForce[i] + FORCE_TOL) {
                        valid = false;
                        violations.push(`F${i+1} force: ${solution.forces[i].toFixed(1)} > ${this.constraints.maxForce[i]} MN`);
                    }
                    if (solution.powers && solution.powers[i] > this.constraints.maxPower[i] + POWER_TOL) {
                        valid = false;
                        violations.push(`F${i+1} power: ${solution.powers[i].toFixed(2)} > ${this.constraints.maxPower[i]} MW`);
                    }
                    if (solution.reductions && solution.reductions[i] > this.constraints.maxReduction[i] + REDUCTION_TOL) {
                        valid = false;
                        violations.push(`F${i+1} reduction too high: ${(solution.reductions[i]*100).toFixed(1)}% > ${(this.constraints.maxReduction[i]*100).toFixed(0)}%`);
                    }
                    if (solution.reductions && solution.reductions[i] < this.constraints.minReduction[i] - REDUCTION_TOL) {
                        valid = false;
                        violations.push(`F${i+1} reduction too low: ${(solution.reductions[i]*100).toFixed(1)}% < ${(this.constraints.minReduction[i]*100).toFixed(0)}%`);
                    }
                }
                
                // Check FDT constraints
                if (solution.temperatures) {
                    const finalTemp = solution.temperatures[numStands];
                    if (finalTemp < this.constraints.targetFDT.min - FDT_TOL) {
                        valid = false;
                        violations.push(`FDT too low: ${finalTemp.toFixed(0)}¬∞C < ${this.constraints.targetFDT.min}¬∞C`);
                    }
                    if (finalTemp > this.constraints.targetFDT.max + FDT_TOL) {
                        valid = false;
                        violations.push(`FDT too high: ${finalTemp.toFixed(0)}¬∞C > ${this.constraints.targetFDT.max}¬∞C`);
                    }
                }
                
                // Check speed constraints
                if (solution.speeds) {
                    const f7Speed = solution.speeds[numStands - 1];
                    if (f7Speed < this.constraints.minSpeed) {
                        valid = false;
                        violations.push(`F7 speed too low: ${f7Speed.toFixed(2)} < ${this.constraints.minSpeed} m/s`);
                    }
                    if (f7Speed > this.constraints.maxSpeed) {
                        valid = false;
                        violations.push(`F7 speed too high: ${f7Speed.toFixed(2)} > ${this.constraints.maxSpeed} m/s`);
                    }
                }
                
                return { valid, violations };
            },
            
            // Analytical optimization (load distribution based)
            analyticalOptimization: function(setup) {
                const H0 = setup.entryThickness;
                const Hf = setup.exitThickness;
                const W = setup.width;
                const T0 = setup.entryTemp;
                const material = setup.material;
                const numStands = 7;
                
                // Calculate optimal reduction distribution using equal load principle
                // Modified for electrical steel (higher Si = higher flow stress)
                const mat = MaterialDatabase.grades[material];
                const siContent = mat ? mat.Si : 1.5;
                
                // Reduction weights adjusted for Si content and stand capacity
                // Higher Si -> shift more reduction to early stands
                const siFactor = 1 + (siContent - 1.5) * 0.08;
                
                // Base reduction pattern weights (decreasing downstream)
                const basePattern = [];
                for (let i = 0; i < numStands; i++) {
                    const baseFactor = Math.pow(0.85, i) * siFactor;
                    basePattern.push(baseFactor * this.constraints.maxForce[i] / 35);
                }
                const sumPattern = basePattern.reduce((a, b) => a + b, 0);
                
                // Use logarithmic distribution to ensure we hit exact target thickness
                const thicknessRatio = Hf / H0;
                const lnRatio = Math.log(thicknessRatio);
                
                let reductions = [];
                let thicknesses = [H0];
                let temperatures = [T0];
                let currentH = H0;
                let currentT = T0;
                
                for (let i = 0; i < numStands; i++) {
                    // Calculate exit thickness using logarithmic distribution
                    const weight = basePattern[i] / sumPattern;
                    const standRatio = Math.exp(weight * lnRatio);
                    let reduction = 1 - standRatio;
                    
                    // Apply constraints
                    reduction = Math.max(this.constraints.minReduction[i], 
                                        Math.min(this.constraints.maxReduction[i], reduction));
                    
                    const exitH = currentH * (1 - reduction);
                    reductions.push(reduction);
                    thicknesses.push(exitH);
                    
                    // More realistic temperature estimation
                    const strain = Math.log(currentH / exitH);
                    
                    // Deformation heating: ~10-20¬∞C per unit strain depending on flow stress
                    const tempRise = 12 * strain;
                    
                    // Cooling losses (more realistic model):
                    // - Roll contact cooling: ~3-8¬∞C per stand (higher for thinner strip)
                    // - Radiation/convection between stands: ~5-10¬∞C
                    // - Inter-stand spray cooling: ~8-15¬∞C per zone at typical flow rates
                    const rollCooling = 3 + (7 - i) * 0.5;  // Higher cooling at upstream stands
                    const radiationLoss = 6 + i * 0.5;      // More loss at downstream (slower, thinner)
                    const sprayCooling = 10;                 // Assume moderate spray cooling per zone
                    
                    // Net temperature change (typically net cooling through FM)
                    const tempLoss = rollCooling + radiationLoss + (i < numStands - 1 ? sprayCooling : 0);
                    currentT = currentT + tempRise - tempLoss;
                    temperatures.push(currentT);
                    
                    currentH = exitH;
                }
                
                // Adjust final thickness to exactly match target
                const actualFinal = thicknesses[numStands];
                if (Math.abs(actualFinal - Hf) > 0.001) {
                    // Redistribute the error across last few stands
                    const error = actualFinal - Hf;
                    const adjustFactor = Hf / actualFinal;
                    
                    // Recalculate from scratch with adjusted ratios
                    currentH = H0;
                    thicknesses = [H0];
                    reductions = [];
                    
                    for (let i = 0; i < numStands; i++) {
                        const weight = basePattern[i] / sumPattern;
                        const standRatio = Math.exp(weight * lnRatio);
                        let exitH = currentH * standRatio;
                        
                        // On last stand, force exact target
                        if (i === numStands - 1) {
                            exitH = Hf;
                        }
                        
                        const reduction = 1 - exitH / currentH;
                        reductions.push(Math.max(0.01, Math.min(0.5, reduction)));
                        thicknesses.push(exitH);
                        currentH = exitH;
                    }
                }
                
                // Calculate speeds (constant mass flow from F7)
                // Use target FDT mid-point for speed calculation
                const targetFDTMid = (this.constraints.targetFDT.min + this.constraints.targetFDT.max) / 2;
                const baseSpeed = this.calculateOptimalF7Speed(targetFDTMid, material);
                let speeds = [];
                for (let i = 0; i < numStands; i++) {
                    speeds.push(baseSpeed * (Hf / thicknesses[i + 1]));
                }
                
                // Recalculate temperatures using proper physics models now that we have speeds
                temperatures = [T0];
                currentT = T0;
                
                // Calculate forces, powers, and accurate temperatures
                let forces = [];
                let powers = [];
                let valid = true;
                let violations = [];
                
                for (let i = 0; i < numStands; i++) {
                    const stand = MillConfig.stands[i];
                    const result = PhysicsModels.calculateRollingForce(
                        stand, material, thicknesses[i], thicknesses[i + 1],
                        W, currentT, speeds[i]
                    );
                    forces.push(result.force);
                    
                    const torque = PhysicsModels.calculateTorque(result.force, result.contactLength, stand.workRollDia);
                    const power = PhysicsModels.calculatePower(torque, speeds[i], stand.workRollDia);
                    powers.push(power);
                    
                    // Calculate temperature change using physics model
                    const tempChange = PhysicsModels.calculateTemperatureChange(
                        material, thicknesses[i], thicknesses[i + 1], currentT,
                        result.force, W, result.contactLength, speeds[i]
                    );
                    
                    // Inter-stand cooling
                    let interstandLoss = 0;
                    if (i < numStands - 1) {
                        interstandLoss = PhysicsModels.calculateInterstandTempLoss(
                            material, thicknesses[i + 1], currentT, 5000, speeds[i]
                        );
                        // Add spray cooling estimate (assume moderate spray flow)
                        if (CoolingSystem.sprays[i] && CoolingSystem.sprays[i].enabled) {
                            const sprayCooling = CoolingSystem.calculateCooling(
                                i, currentT + tempChange.netChange,
                                thicknesses[i + 1], W, speeds[i], material
                            );
                            interstandLoss -= sprayCooling.tempDrop;
                        }
                    }
                    
                    currentT = currentT + tempChange.netChange + interstandLoss;
                    temperatures.push(currentT);
                    
                    // Tolerance values for floating-point comparisons
                    const FORCE_TOL = 0.1;      // 0.1 MN
                    const POWER_TOL = 0.05;     // 0.05 MW
                    const REDUCTION_TOL = 0.002; // 0.2% (as decimal)
                    
                    if (result.force > this.constraints.maxForce[i] + FORCE_TOL) {
                        valid = false;
                        violations.push(`F${i+1} force: ${result.force.toFixed(1)} > ${this.constraints.maxForce[i]} MN`);
                    }
                    if (power > this.constraints.maxPower[i] + POWER_TOL) {
                        valid = false;
                        violations.push(`F${i+1} power: ${power.toFixed(2)} > ${this.constraints.maxPower[i]} MW`);
                    }
                    if (reductions[i] > this.constraints.maxReduction[i] + REDUCTION_TOL) {
                        valid = false;
                        violations.push(`F${i+1} reduction too high: ${(reductions[i]*100).toFixed(1)}% > ${(this.constraints.maxReduction[i]*100).toFixed(0)}%`);
                    }
                    if (reductions[i] < this.constraints.minReduction[i] - REDUCTION_TOL) {
                        valid = false;
                        violations.push(`F${i+1} reduction too low: ${(reductions[i]*100).toFixed(1)}% < ${(this.constraints.minReduction[i]*100).toFixed(0)}%`);
                    }
                }
                
                // Check FDT constraints (with 1¬∞C tolerance for practical operation)
                const finalTemp = temperatures[numStands];
                if (finalTemp < this.constraints.targetFDT.min - 1.0) {
                    valid = false;
                    violations.push(`FDT too low: ${finalTemp.toFixed(0)}¬∞C < ${this.constraints.targetFDT.min}¬∞C`);
                }
                if (finalTemp > this.constraints.targetFDT.max + 1.0) {
                    valid = false;
                    violations.push(`FDT too high: ${finalTemp.toFixed(0)}¬∞C > ${this.constraints.targetFDT.max}¬∞C`);
                }
                
                if (!valid) {
                    console.warn('=== ANALYTICAL OPTIMIZATION CONSTRAINT VIOLATIONS ===');
                    violations.forEach(v => console.warn('  ‚Ä¢ ' + v));
                }
                
                // Calculate fitness
                const fitness = this.calculateFitness({
                    thicknesses, reductions, speeds, forces, powers, temperatures
                }, setup);
                
                this.history.iterations.push(0);
                this.history.fitness.push(fitness);
                
                if (fitness < this.bestFitness) {
                    this.bestFitness = fitness;
                }
                
                return {
                    thicknesses,
                    reductions,
                    speeds,
                    forces,
                    powers,
                    temperatures,
                    fitness,
                    valid,
                    violations,
                    method: 'analytical'
                };
            },
            
            // Gradient-based optimization (refine existing solution)
            gradientOptimization: function(setup, initialSolution = null) {
                const numStands = 7;
                let solution = initialSolution || this.analyticalOptimization(setup);
                
                const learningRate = 0.01;
                const epsilon = 0.001;
                
                for (let iter = 0; iter < this.config.maxIterations; iter++) {
                    // Calculate gradient for each reduction
                    let gradients = [];
                    const baseFitness = this.calculateFitness(solution, setup);
                    
                    for (let i = 0; i < numStands - 1; i++) {
                        // Perturb reduction
                        let perturbedReductions = [...solution.reductions];
                        perturbedReductions[i] += epsilon;
                        
                        // Recalculate schedule with perturbed reduction
                        const perturbedSolution = this.recalculateSchedule(
                            setup, perturbedReductions
                        );
                        const perturbedFitness = this.calculateFitness(perturbedSolution, setup);
                        
                        gradients.push((perturbedFitness - baseFitness) / epsilon);
                    }
                    
                    // Update reductions (gradient descent)
                    let newReductions = [...solution.reductions];
                    let maxGradient = Math.max(...gradients.map(Math.abs));
                    
                    for (let i = 0; i < numStands - 1; i++) {
                        const normalizedGrad = gradients[i] / (maxGradient + 1e-8);
                        newReductions[i] -= learningRate * normalizedGrad;
                        
                        // Apply constraints
                        newReductions[i] = Math.max(this.constraints.minReduction[i],
                                                   Math.min(this.constraints.maxReduction[i], newReductions[i]));
                    }
                    
                    // Recalculate full solution
                    const newSolution = this.recalculateSchedule(setup, newReductions);
                    const newFitness = this.calculateFitness(newSolution, setup);
                    
                    this.history.iterations.push(iter + 1);
                    this.history.fitness.push(newFitness);
                    
                    // Check convergence
                    if (Math.abs(newFitness - baseFitness) < this.config.convergenceTol) {
                        console.log(`Gradient optimization converged at iteration ${iter}`);
                        break;
                    }
                    
                    if (newFitness < baseFitness) {
                        solution = newSolution;
                        solution.fitness = newFitness;
                        if (newFitness < this.bestFitness) {
                            this.bestFitness = newFitness;
                        }
                    }
                }
                
                // Ensure fitness is set on solution
                if (solution.fitness === undefined) {
                    solution.fitness = this.calculateFitness(solution, setup);
                }
                
                solution.method = 'gradient';
                return solution;
            },
            
            // Genetic algorithm optimization
            geneticOptimization: function(setup) {
                const numStands = 7;
                const popSize = this.config.populationSize;
                
                // Initialize population
                let population = [];
                for (let i = 0; i < popSize; i++) {
                    const reductions = this.generateRandomReductions(setup);
                    const solution = this.recalculateSchedule(setup, reductions);
                    solution.fitness = this.calculateFitness(solution, setup);
                    population.push(solution);
                }
                
                // Evolution loop
                for (let gen = 0; gen < this.config.maxIterations; gen++) {
                    // Sort by fitness
                    population.sort((a, b) => a.fitness - b.fitness);
                    
                    // Record best
                    this.history.iterations.push(gen);
                    this.history.fitness.push(population[0].fitness);
                    
                    if (population[0].fitness < this.bestFitness) {
                        this.bestFitness = population[0].fitness;
                        this.bestSolution = population[0];
                    }
                    
                    // Create new population
                    let newPopulation = [];
                    
                    // Elitism: keep best solutions
                    for (let i = 0; i < this.config.eliteCount; i++) {
                        newPopulation.push(population[i]);
                    }
                    
                    // Generate rest through crossover and mutation
                    while (newPopulation.length < popSize) {
                        // Tournament selection
                        const parent1 = this.tournamentSelect(population);
                        const parent2 = this.tournamentSelect(population);
                        
                        // Crossover
                        let childReductions;
                        if (Math.random() < this.config.crossoverRate) {
                            childReductions = this.crossover(parent1.reductions, parent2.reductions);
                        } else {
                            childReductions = [...parent1.reductions];
                        }
                        
                        // Mutation
                        if (Math.random() < this.config.mutationRate) {
                            childReductions = this.mutate(childReductions);
                        }
                        
                        // Create solution
                        const child = this.recalculateSchedule(setup, childReductions);
                        child.fitness = this.calculateFitness(child, setup);
                        newPopulation.push(child);
                    }
                    
                    population = newPopulation;
                }
                
                // Return best solution
                population.sort((a, b) => a.fitness - b.fitness);
                population[0].method = 'genetic';
                return population[0];
            },
            
            // Generate random reduction schedule
            generateRandomReductions: function(setup) {
                const H0 = setup.entryThickness;
                const Hf = setup.exitThickness;
                const numStands = 7;
                
                let reductions = [];
                let currentH = H0;
                
                for (let i = 0; i < numStands - 1; i++) {
                    const minRed = this.constraints.minReduction[i];
                    const maxRed = Math.min(this.constraints.maxReduction[i], 1 - Hf / currentH - 0.1);
                    const red = minRed + Math.random() * (maxRed - minRed);
                    reductions.push(red);
                    currentH = currentH * (1 - red);
                }
                
                // Last stand: whatever is needed
                reductions.push(1 - Hf / currentH);
                
                return reductions;
            },
            
            // Tournament selection
            tournamentSelect: function(population, tournamentSize = 3) {
                let best = null;
                for (let i = 0; i < tournamentSize; i++) {
                    const idx = Math.floor(Math.random() * population.length);
                    if (!best || population[idx].fitness < best.fitness) {
                        best = population[idx];
                    }
                }
                return best;
            },
            
            // Crossover operator
            crossover: function(parent1, parent2) {
                const crossPoint = Math.floor(Math.random() * parent1.length);
                return [
                    ...parent1.slice(0, crossPoint),
                    ...parent2.slice(crossPoint)
                ];
            },
            
            // Mutation operator
            mutate: function(reductions) {
                const idx = Math.floor(Math.random() * reductions.length);
                const delta = (Math.random() - 0.5) * 0.1;
                reductions[idx] = Math.max(
                    this.constraints.minReduction[idx],
                    Math.min(this.constraints.maxReduction[idx], reductions[idx] + delta)
                );
                return reductions;
            },
            
            // Recalculate full schedule from reductions
            recalculateSchedule: function(setup, reductions) {
                const H0 = setup.entryThickness;
                const Hf = setup.exitThickness;
                const W = setup.width;
                const T0 = setup.entryTemp;
                const material = setup.material;
                const numStands = 7;
                
                // Ensure reductions array has correct length
                let safeReductions = [...reductions];
                while (safeReductions.length < numStands) {
                    safeReductions.push(0.15); // Default reduction
                }
                
                let thicknesses = [H0];
                let temperatures = [T0];
                let currentH = H0;
                let currentT = T0;
                
                // Calculate thicknesses for stands 1-6 (not the last stand yet)
                for (let i = 0; i < numStands - 1; i++) {
                    const exitH = currentH * (1 - safeReductions[i]);
                    // Don't allow thickness to go below target (would require negative reduction at F7)
                    thicknesses.push(Math.max(exitH, Hf * 1.03)); // Leave at least 3% reduction for F7
                    currentH = thicknesses[i + 1];
                }
                
                // Calculate F7 (last stand) thickness to hit target
                // First check what reduction would be needed
                const f7EntryH = currentH;
                let lastReduction = 1 - Hf / f7EntryH;
                
                // Check if last reduction is physically achievable
                const minLastRed = this.constraints.minReduction[numStands - 1];
                const maxLastRed = this.constraints.maxReduction[numStands - 1];
                
                let f7ExitH;
                if (lastReduction < minLastRed || lastReduction > maxLastRed) {
                    console.warn(`F7 reduction ${(lastReduction*100).toFixed(1)}% outside limits [${(minLastRed*100).toFixed(0)}%-${(maxLastRed*100).toFixed(0)}%]`);
                    // Clamp to valid range
                    lastReduction = Math.max(minLastRed, Math.min(maxLastRed, lastReduction));
                    // Recalculate final thickness based on clamped reduction
                    f7ExitH = f7EntryH * (1 - lastReduction);
                    console.warn(`Target thickness adjusted: ${Hf.toFixed(3)} ‚Üí ${f7ExitH.toFixed(3)} mm`);
                } else {
                    f7ExitH = Hf;
                }
                thicknesses.push(f7ExitH);  // Now thicknesses has 8 elements [H0, H1, H2, H3, H4, H5, H6, H7]
                safeReductions[numStands - 1] = lastReduction;
                
                // Calculate base speed
                const targetFDT = (this.constraints.targetFDT.min + this.constraints.targetFDT.max) / 2;
                const baseSpeed = this.calculateOptimalF7Speed(targetFDT, material);
                
                // Calculate speeds using mass flow conservation
                // V * H = constant, so V[i] = V_f7 * H_f7 / H[i]
                const actualFinalH = thicknesses[numStands];
                let speeds = [];
                for (let i = 0; i < numStands; i++) {
                    speeds.push(baseSpeed * (actualFinalH / thicknesses[i + 1]));
                }
                
                // Calculate forces, powers, and temperatures
                let forces = [];
                let powers = [];
                currentT = T0;
                
                for (let i = 0; i < numStands; i++) {
                    const stand = MillConfig.stands[i];
                    
                    // Rolling force
                    const result = PhysicsModels.calculateRollingForce(
                        stand, material, thicknesses[i], thicknesses[i + 1],
                        W, currentT, speeds[i]
                    );
                    forces.push(result.force);
                    
                    // Torque and power
                    const torque = PhysicsModels.calculateTorque(
                        result.force, result.contactLength, stand.workRollDia
                    );
                    const power = PhysicsModels.calculatePower(torque, speeds[i], stand.workRollDia);
                    powers.push(power);
                    
                    // Temperature
                    const tempChange = PhysicsModels.calculateTemperatureChange(
                        material, thicknesses[i], thicknesses[i + 1], currentT,
                        result.force, W, result.contactLength, speeds[i]
                    );
                    
                    // Inter-stand cooling (including spray effect)
                    let interstandLoss = 0;
                    if (i < numStands - 1) {
                        interstandLoss = PhysicsModels.calculateInterstandTempLoss(
                            material, thicknesses[i + 1], currentT, 5000, speeds[i]
                        );
                        // Add spray cooling estimate
                        if (CoolingSystem.sprays[i] && CoolingSystem.sprays[i].enabled) {
                            const sprayCooling = CoolingSystem.calculateCooling(
                                i, currentT + tempChange.netChange, 
                                thicknesses[i + 1], W, speeds[i], material
                            );
                            interstandLoss -= sprayCooling.tempDrop;
                        }
                    }
                    
                    currentT = currentT + tempChange.netChange + interstandLoss;
                    temperatures.push(currentT);
                }
                
                // Validate constraints with detailed logging
                let valid = true;
                let violations = [];
                
                // Tolerance values for floating-point comparisons
                const FORCE_TOL = 0.1;      // 0.1 MN
                const POWER_TOL = 0.05;     // 0.05 MW
                const REDUCTION_TOL = 0.002; // 0.2% (as decimal)
                
                for (let i = 0; i < numStands; i++) {
                    if (forces[i] > this.constraints.maxForce[i] + FORCE_TOL) {
                        valid = false;
                        violations.push(`F${i+1} force: ${forces[i].toFixed(1)} > ${this.constraints.maxForce[i]} MN`);
                    }
                    if (powers[i] > this.constraints.maxPower[i] + POWER_TOL) {
                        valid = false;
                        violations.push(`F${i+1} power: ${powers[i].toFixed(2)} > ${this.constraints.maxPower[i]} MW`);
                    }
                    if (safeReductions[i] > this.constraints.maxReduction[i] + REDUCTION_TOL) {
                        valid = false;
                        violations.push(`F${i+1} reduction too high: ${(safeReductions[i]*100).toFixed(1)}% > ${(this.constraints.maxReduction[i]*100).toFixed(0)}%`);
                    }
                    if (safeReductions[i] < this.constraints.minReduction[i] - REDUCTION_TOL) {
                        valid = false;
                        violations.push(`F${i+1} reduction too low: ${(safeReductions[i]*100).toFixed(1)}% < ${(this.constraints.minReduction[i]*100).toFixed(0)}%`);
                    }
                }
                
                const finalTemp = temperatures[numStands];
                // Use 1¬∞C tolerance for practical operation (temperature measurement uncertainty)
                if (finalTemp < this.constraints.targetFDT.min - 1.0) {
                    valid = false;
                    violations.push(`FDT too low: ${finalTemp.toFixed(0)}¬∞C < ${this.constraints.targetFDT.min}¬∞C`);
                }
                if (finalTemp > this.constraints.targetFDT.max + 1.0) {
                    valid = false;
                    violations.push(`FDT too high: ${finalTemp.toFixed(0)}¬∞C > ${this.constraints.targetFDT.max}¬∞C`);
                }
                
                if (!valid) {
                    // Only log constraint violations occasionally to avoid spam
                    // Use a static counter to track logging frequency
                    if (!this._violationLogCount) this._violationLogCount = 0;
                    this._violationLogCount++;
                    
                    // Log first occurrence and then every 50th
                    if (this._violationLogCount === 1 || this._violationLogCount % 50 === 0) {
                        console.warn('=== CONSTRAINT VIOLATIONS ===');
                        violations.forEach(v => console.warn('  ‚Ä¢ ' + v));
                        console.warn('Schedule summary:');
                        console.warn('  Thicknesses:', thicknesses.map(h => h.toFixed(3)).join(' ‚Üí '));
                        console.warn('  Reductions:', safeReductions.map(r => (r*100).toFixed(1) + '%').join(', '));
                        console.warn('  Forces:', forces.map(f => f.toFixed(1) + ' MN').join(', '));
                        console.warn('  Powers:', powers.map(p => p.toFixed(2) + ' MW').join(', '));
                        console.warn('  FDT:', finalTemp.toFixed(0) + '¬∞C (target: ' + this.constraints.targetFDT.min + '-' + this.constraints.targetFDT.max + '¬∞C)');
                        if (this._violationLogCount > 1) {
                            console.warn('  (Suppressed ' + (this._violationLogCount - 1) + ' similar warnings)');
                        }
                    }
                } else {
                    // Reset counter when we find a valid solution
                    this._violationLogCount = 0;
                }
                
                return {
                    thicknesses,
                    reductions: safeReductions,
                    speeds,
                    forces,
                    powers,
                    temperatures,
                    valid,
                    violations  // Include violations in result for UI display
                };
            },
            
            // Calculate optimal F7 speed based on target FDT
            calculateOptimalF7Speed: function(targetFDT, material) {
                // Higher speed = less time for cooling = higher FDT
                // Base relationship calibrated for electrical steel
                const mat = MaterialDatabase.grades[material];
                const baseSpeed = 8; // m/s
                
                if (mat) {
                    const targetMid = (mat.targetFDT.min + mat.targetFDT.max) / 2;
                    // Adjust speed to hit target (simplified)
                    const speedAdj = 1 + (targetFDT - targetMid) * 0.005;
                    return baseSpeed * Math.max(0.5, Math.min(1.5, speedAdj));
                }
                return baseSpeed;
            },
            
            // ============================================================
            // SPEED-BASED FDT CONTROL
            // Iteratively adjusts F7 speed to achieve target FDT
            // ============================================================
            optimizeSpeedForFDT: function(solution, setup) {
                if (!this.config.enableSpeedOptimization) {
                    return solution;
                }
                
                const targetFDT = (this.constraints.targetFDT.min + this.constraints.targetFDT.max) / 2;
                const tolerance = this.config.fdtTolerance;
                const numStands = 7;
                let currentSolution = { ...solution, speeds: [...solution.speeds], temperatures: [...solution.temperatures] };
                let currentFDT = currentSolution.temperatures[numStands];
                
                console.log(`Speed optimization: Initial FDT=${currentFDT.toFixed(1)}¬∞C, Target=${targetFDT.toFixed(1)}¬∞C`);
                
                // Use bisection method for robust convergence
                let lowSpeed = this.constraints.minSpeed;
                let highSpeed = this.constraints.maxSpeed;
                let lowFDT = null;
                let highFDT = null;
                
                // Helper function to calculate FDT for a given F7 speed
                const calculateFDTForSpeed = (f7Speed) => {
                    const newSpeeds = [];
                    for (let i = 0; i < numStands; i++) {
                        const exitH = currentSolution.thicknesses[i + 1];
                        const f7ExitH = currentSolution.thicknesses[numStands];
                        newSpeeds.push(f7Speed * (f7ExitH / exitH));
                    }
                    
                    let temperatures = [setup.entryTemp];
                    let currentT = setup.entryTemp;
                    
                    for (let i = 0; i < numStands; i++) {
                        const stand = MillConfig.stands[i];
                        const entryH = currentSolution.thicknesses[i];
                        const exitH = currentSolution.thicknesses[i + 1];
                        
                        const result = PhysicsModels.calculateRollingForce(
                            stand, setup.material, entryH, exitH,
                            setup.width, currentT, newSpeeds[i]
                        );
                        
                        const tempChange = PhysicsModels.calculateTemperatureChange(
                            setup.material, entryH, exitH, currentT,
                            result.force, setup.width, result.contactLength, newSpeeds[i]
                        );
                        
                        let interstandLoss = 0;
                        if (i < numStands - 1) {
                            interstandLoss = PhysicsModels.calculateInterstandTempLoss(
                                setup.material, exitH, currentT, 5000, newSpeeds[i]
                            );
                            if (CoolingSystem.sprays[i] && CoolingSystem.sprays[i].enabled) {
                                const sprayCooling = CoolingSystem.calculateCooling(
                                    i, currentT + tempChange.netChange,
                                    exitH, setup.width, newSpeeds[i], setup.material
                                );
                                interstandLoss -= sprayCooling.tempDrop;
                            }
                        }
                        
                        currentT = currentT + tempChange.netChange + interstandLoss;
                        temperatures.push(currentT);
                    }
                    
                    return { speeds: newSpeeds, temperatures, fdt: temperatures[numStands] };
                };
                
                // First, establish the FDT range at speed limits
                const lowResult = calculateFDTForSpeed(lowSpeed);
                const highResult = calculateFDTForSpeed(highSpeed);
                lowFDT = lowResult.fdt;
                highFDT = highResult.fdt;
                
                console.log(`Speed range: ${lowSpeed} m/s (FDT=${lowFDT.toFixed(0)}¬∞C) to ${highSpeed} m/s (FDT=${highFDT.toFixed(0)}¬∞C)`);
                
                // Check if target is achievable
                if (targetFDT < lowFDT) {
                    console.log(`Target FDT ${targetFDT}¬∞C below achievable range. Using min speed.`);
                    currentSolution.speeds = lowResult.speeds;
                    currentSolution.temperatures = lowResult.temperatures;
                    currentSolution.speedOptimized = true;
                    return currentSolution;
                }
                if (targetFDT > highFDT) {
                    console.log(`Target FDT ${targetFDT}¬∞C above achievable range. Using max speed.`);
                    currentSolution.speeds = highResult.speeds;
                    currentSolution.temperatures = highResult.temperatures;
                    currentSolution.speedOptimized = true;
                    return currentSolution;
                }
                
                // Bisection search for optimal speed
                for (let iter = 0; iter < this.config.speedIterations; iter++) {
                    const midSpeed = (lowSpeed + highSpeed) / 2;
                    const midResult = calculateFDTForSpeed(midSpeed);
                    const midFDT = midResult.fdt;
                    
                    console.log(`Speed iteration ${iter + 1}: F7 speed=${midSpeed.toFixed(2)} m/s, FDT=${midFDT.toFixed(1)}¬∞C`);
                    
                    // Check convergence
                    if (Math.abs(midFDT - targetFDT) <= tolerance) {
                        console.log(`Speed optimization converged: FDT=${midFDT.toFixed(1)}¬∞C`);
                        currentSolution.speeds = midResult.speeds;
                        currentSolution.temperatures = midResult.temperatures;
                        currentSolution.speedOptimized = true;
                        return currentSolution;
                    }
                    
                    // Narrow the search range
                    // Higher speed = higher FDT (less cooling time)
                    if (midFDT < targetFDT) {
                        // Need higher FDT, increase speed
                        lowSpeed = midSpeed;
                        lowFDT = midFDT;
                    } else {
                        // Need lower FDT, decrease speed
                        highSpeed = midSpeed;
                        highFDT = midFDT;
                    }
                    
                    // Check if range is too narrow
                    if (highSpeed - lowSpeed < 0.05) {
                        console.log(`Speed optimization: Range narrowed to ${lowSpeed.toFixed(2)}-${highSpeed.toFixed(2)} m/s`);
                        break;
                    }
                }
                
                // Use the best result found
                const finalSpeed = (lowSpeed + highSpeed) / 2;
                const finalResult = calculateFDTForSpeed(finalSpeed);
                currentSolution.speeds = finalResult.speeds;
                currentSolution.temperatures = finalResult.temperatures;
                currentSolution.speedOptimized = true;
                
                console.log(`Speed optimization final: F7 speed=${finalSpeed.toFixed(2)} m/s, FDT=${finalResult.fdt.toFixed(1)}¬∞C`);
                return currentSolution;
            },
            
            // ============================================================
            // SPRAY COOLING OPTIMIZATION
            // Adjusts inter-stand spray flows to fine-tune FDT
            // ============================================================
            optimizeSprayCooling: function(solution, setup) {
                if (!this.config.enableSprayOptimization) {
                    return solution;
                }
                
                const targetFDT = (this.constraints.targetFDT.min + this.constraints.targetFDT.max) / 2;
                const tolerance = this.config.fdtTolerance;
                const numStands = 7;
                const numSprays = 6;
                let currentSolution = { ...solution, temperatures: [...solution.temperatures] };
                let currentFDT = currentSolution.temperatures[numStands];
                
                // Store original spray settings
                const originalSprayFlows = [];
                for (let i = 0; i < numSprays; i++) {
                    originalSprayFlows.push(CoolingSystem.sprays[i].flowSetpoint);
                }
                
                console.log(`Spray optimization: Initial FDT=${currentFDT.toFixed(1)}¬∞C, Target=${targetFDT.toFixed(1)}¬∞C`);
                
                // Check if already within tolerance
                if (Math.abs(currentFDT - targetFDT) <= tolerance) {
                    console.log(`Spray optimization: Already within tolerance`);
                    currentSolution.sprayFlows = originalSprayFlows;
                    currentSolution.sprayOptimized = true;
                    return currentSolution;
                }
                
                // Helper to calculate FDT for a given uniform spray flow
                const calculateFDTForSprayFlow = (flowPercent) => {
                    // Set all sprays to this flow
                    for (let i = 0; i < numSprays; i++) {
                        CoolingSystem.sprays[i].flowSetpoint = flowPercent;
                        CoolingSystem.sprays[i].actualFlow = flowPercent;
                    }
                    
                    let temperatures = [setup.entryTemp];
                    let currentT = setup.entryTemp;
                    
                    for (let i = 0; i < numStands; i++) {
                        const stand = MillConfig.stands[i];
                        const entryH = currentSolution.thicknesses[i];
                        const exitH = currentSolution.thicknesses[i + 1];
                        const speed = currentSolution.speeds[i];
                        
                        const result = PhysicsModels.calculateRollingForce(
                            stand, setup.material, entryH, exitH,
                            setup.width, currentT, speed
                        );
                        
                        const tempChange = PhysicsModels.calculateTemperatureChange(
                            setup.material, entryH, exitH, currentT,
                            result.force, setup.width, result.contactLength, speed
                        );
                        
                        let interstandLoss = 0;
                        if (i < numStands - 1) {
                            interstandLoss = PhysicsModels.calculateInterstandTempLoss(
                                setup.material, exitH, currentT, 5000, speed
                            );
                            if (CoolingSystem.sprays[i] && CoolingSystem.sprays[i].enabled) {
                                const sprayCooling = CoolingSystem.calculateCooling(
                                    i, currentT + tempChange.netChange,
                                    exitH, setup.width, speed, setup.material
                                );
                                interstandLoss -= sprayCooling.tempDrop;
                            }
                        }
                        
                        currentT = currentT + tempChange.netChange + interstandLoss;
                        temperatures.push(currentT);
                    }
                    
                    return { temperatures, fdt: temperatures[numStands] };
                };
                
                // Use bisection to find optimal spray flow
                let lowFlow = this.constraints.minSprayFlow;
                let highFlow = this.constraints.maxSprayFlow;
                
                const lowResult = calculateFDTForSprayFlow(lowFlow);
                const highResult = calculateFDTForSprayFlow(highFlow);
                
                console.log(`Spray range: ${lowFlow}% (FDT=${lowResult.fdt.toFixed(0)}¬∞C) to ${highFlow}% (FDT=${highResult.fdt.toFixed(0)}¬∞C)`);
                
                // Higher spray = lower FDT
                // Check if target is achievable
                if (targetFDT > lowResult.fdt) {
                    console.log(`Target FDT ${targetFDT.toFixed(0)}¬∞C above achievable range. Using min spray.`);
                    currentSolution.temperatures = lowResult.temperatures;
                    currentSolution.sprayFlows = Array(numSprays).fill(lowFlow);
                    currentSolution.sprayOptimized = true;
                    return currentSolution;
                }
                if (targetFDT < highResult.fdt) {
                    console.log(`Target FDT ${targetFDT.toFixed(0)}¬∞C below achievable range. Using max spray.`);
                    currentSolution.temperatures = highResult.temperatures;
                    currentSolution.sprayFlows = Array(numSprays).fill(highFlow);
                    currentSolution.sprayOptimized = true;
                    return currentSolution;
                }
                
                // Bisection search
                for (let iter = 0; iter < this.config.sprayIterations * 2; iter++) {
                    const midFlow = (lowFlow + highFlow) / 2;
                    const midResult = calculateFDTForSprayFlow(midFlow);
                    
                    console.log(`Spray iteration ${iter + 1}: Flow=${midFlow.toFixed(0)}%, FDT=${midResult.fdt.toFixed(1)}¬∞C`);
                    
                    if (Math.abs(midResult.fdt - targetFDT) <= tolerance) {
                        console.log(`Spray optimization converged: Flow=${midFlow.toFixed(0)}%, FDT=${midResult.fdt.toFixed(1)}¬∞C`);
                        currentSolution.temperatures = midResult.temperatures;
                        currentSolution.sprayFlows = Array(numSprays).fill(midFlow);
                        currentSolution.sprayOptimized = true;
                        return currentSolution;
                    }
                    
                    // Higher spray = lower FDT
                    if (midResult.fdt > targetFDT) {
                        // Need lower FDT, increase spray
                        lowFlow = midFlow;
                    } else {
                        // Need higher FDT, decrease spray
                        highFlow = midFlow;
                    }
                    
                    if (highFlow - lowFlow < 1) {
                        console.log(`Spray optimization: Range narrowed to ${lowFlow.toFixed(0)}-${highFlow.toFixed(0)}%`);
                        break;
                    }
                }
                
                // Use best result
                const finalFlow = (lowFlow + highFlow) / 2;
                const finalResult = calculateFDTForSprayFlow(finalFlow);
                currentSolution.temperatures = finalResult.temperatures;
                currentSolution.sprayFlows = Array(numSprays).fill(finalFlow);
                currentSolution.sprayOptimized = true;
                
                console.log(`Spray optimization final: Flow=${finalFlow.toFixed(0)}%, FDT=${finalResult.fdt.toFixed(1)}¬∞C`);
                return currentSolution;
            },
            
            // ============================================================
            // COMBINED FDT OPTIMIZATION
            // Uses both speed and spray control for optimal FDT
            // ============================================================
            optimizeFDT: function(solution, setup) {
                let optimizedSolution = { ...solution };
                
                const targetFDT = (this.constraints.targetFDT.min + this.constraints.targetFDT.max) / 2;
                const initialFDT = solution.temperatures[7];
                
                console.log('=== FDT OPTIMIZATION START ===');
                console.log(`Initial FDT: ${initialFDT.toFixed(1)}¬∞C, Target: ${targetFDT.toFixed(1)}¬∞C`);
                
                // Step 1: Coarse adjustment with speed
                if (this.config.enableSpeedOptimization) {
                    optimizedSolution = this.optimizeSpeedForFDT(optimizedSolution, setup);
                }
                
                // Step 2: Fine adjustment with spray cooling
                if (this.config.enableSprayOptimization) {
                    optimizedSolution = this.optimizeSprayCooling(optimizedSolution, setup);
                }
                
                const finalFDT = optimizedSolution.temperatures[7];
                console.log(`Final FDT: ${finalFDT.toFixed(1)}¬∞C (Œî=${(finalFDT - initialFDT).toFixed(1)}¬∞C)`);
                console.log('=== FDT OPTIMIZATION END ===');
                
                return optimizedSolution;
            },
            
            // Fitness function
            calculateFitness: function(solution, setup) {
                let fitness = 0;
                const numStands = 7;
                
                // Validate solution
                if (!solution || !solution.thicknesses || !solution.forces || !solution.temperatures) {
                    console.warn('Invalid solution for fitness calculation');
                    return Infinity;
                }
                
                // Ensure powers array exists
                if (!solution.powers || solution.powers.length === 0) {
                    solution.powers = solution.forces.map((f, i) => f * 0.5); // Estimate
                }
                
                // 1. Thickness accuracy (exit thickness vs target)
                const thicknessError = Math.abs(solution.thicknesses[numStands] - setup.exitThickness);
                fitness += this.weights.thickness * thicknessError * 100;
                
                // 2. FDT accuracy
                const targetFDT = (this.constraints.targetFDT.min + this.constraints.targetFDT.max) / 2;
                const fdtError = Math.abs(solution.temperatures[numStands] - targetFDT);
                fitness += this.weights.temperature * fdtError * 0.1;
                
                // Penalty for FDT out of range
                if (solution.temperatures[numStands] < this.constraints.targetFDT.min) {
                    fitness += 50 * (this.constraints.targetFDT.min - solution.temperatures[numStands]);
                }
                if (solution.temperatures[numStands] > this.constraints.targetFDT.max) {
                    fitness += 50 * (solution.temperatures[numStands] - this.constraints.targetFDT.max);
                }
                
                // 3. Force balance (prefer even distribution)
                const avgForce = solution.forces.reduce((a, b) => a + b, 0) / numStands;
                const forceVariance = solution.forces.reduce((sum, f) => 
                    sum + Math.pow(f - avgForce, 2), 0) / numStands;
                fitness += this.weights.force * Math.sqrt(forceVariance);
                
                // Penalty for exceeding force limits
                for (let i = 0; i < numStands; i++) {
                    if (solution.forces[i] > this.constraints.maxForce[i]) {
                        fitness += 100 * (solution.forces[i] - this.constraints.maxForce[i]);
                    }
                }
                
                // 4. Power consumption
                const totalPower = solution.powers.reduce((a, b) => a + b, 0);
                fitness += this.weights.power * totalPower * 0.5;
                
                // Penalty for exceeding power limits
                for (let i = 0; i < numStands; i++) {
                    if (solution.powers[i] > this.constraints.maxPower[i]) {
                        fitness += 100 * (solution.powers[i] - this.constraints.maxPower[i]);
                    }
                }
                
                // 5. Productivity (higher F7 speed is better)
                const f7Speed = solution.speeds[numStands - 1];
                fitness -= this.weights.productivity * f7Speed * 0.5;
                
                // 6. Reduction distribution smoothness
                let reductionVariance = 0;
                for (let i = 1; i < numStands; i++) {
                    reductionVariance += Math.pow(
                        solution.reductions[i] - solution.reductions[i - 1], 2
                    );
                }
                fitness += 5 * Math.sqrt(reductionVariance);
                
                return fitness;
            },
            
            // Optimize cooling spray settings for target FDT
            optimizeCooling: function(schedule, targetFDT, material, width) {
                const numZones = 6;
                const tolerance = 2.0; // ¬∞C - tighter tolerance
                
                console.log(`=== ISC OPTIMIZATION START ===`);
                console.log(`Target FDT: ${targetFDT}¬∞C, Material: ${material}`);
                
                // Helper to calculate FDT for a given uniform spray flow
                // This matches the simulation loop more closely
                const calculateFDTForSprayFlow = (flowPercent) => {
                    // Set all sprays to this flow (matching simulation)
                    for (let i = 0; i < numZones; i++) {
                        CoolingSystem.sprays[i].flowSetpoint = flowPercent;
                        CoolingSystem.sprays[i].actualFlow = flowPercent;
                    }
                    
                    // Use entry temperature from simulation if available
                    let currentT = SimulationEngine.strip ? 
                        SimulationEngine.strip.entryTemperature : schedule.temperatures[0];
                    
                    for (let i = 0; i < 7; i++) {
                        const stand = MillConfig.stands[i];
                        const entryH = schedule.thicknesses[i];
                        const exitH = schedule.thicknesses[i + 1];
                        const speed = schedule.speeds[i];
                        
                        const result = PhysicsModels.calculateRollingForce(
                            stand, material, entryH, exitH,
                            width, currentT, speed
                        );
                        
                        const tempChange = PhysicsModels.calculateTemperatureChange(
                            material, entryH, exitH, currentT,
                            result.force, width, result.contactLength, speed
                        );
                        
                        // Apply deformation heating
                        currentT += tempChange.netChange;
                        
                        // Inter-stand cooling (radiation + spray) - only between stands
                        if (i < 6) {
                            const interstandLoss = PhysicsModels.calculateInterstandTempLoss(
                                material, exitH, currentT, 5000, speed
                            );
                            currentT += interstandLoss; // This is negative (cooling)
                            
                            // Spray cooling
                            if (CoolingSystem.sprays[i] && CoolingSystem.sprays[i].enabled) {
                                const sprayCooling = CoolingSystem.calculateCooling(
                                    i, currentT, exitH, width, speed, material
                                );
                                currentT -= sprayCooling.tempDrop;
                            }
                        }
                    }
                    
                    return currentT; // FDT
                };
                
                // Use bisection to find optimal spray flow
                let lowFlow = 0;
                let highFlow = 100;
                
                const lowFDT = calculateFDTForSprayFlow(lowFlow);
                const highFDT = calculateFDTForSprayFlow(highFlow);
                
                console.log(`Spray range: ${lowFlow}% ‚Üí FDT=${lowFDT.toFixed(0)}¬∞C, ${highFlow}% ‚Üí FDT=${highFDT.toFixed(0)}¬∞C`);
                
                // Higher spray = lower FDT
                let optimalFlow = 50;
                let achievedFDT = targetFDT;
                
                if (targetFDT > lowFDT) {
                    console.log(`Target FDT ${targetFDT}¬∞C above achievable minimum (${lowFDT.toFixed(0)}¬∞C). Using min spray.`);
                    optimalFlow = lowFlow;
                    achievedFDT = lowFDT;
                } else if (targetFDT < highFDT) {
                    console.log(`Target FDT ${targetFDT}¬∞C below achievable maximum (${highFDT.toFixed(0)}¬∞C). Using max spray.`);
                    optimalFlow = highFlow;
                    achievedFDT = highFDT;
                } else {
                    // Bisection search - more iterations for better accuracy
                    for (let iter = 0; iter < 20; iter++) {
                        const midFlow = (lowFlow + highFlow) / 2;
                        const midFDT = calculateFDTForSprayFlow(midFlow);
                        
                        if (iter < 5 || Math.abs(midFDT - targetFDT) < 10) {
                            console.log(`Iteration ${iter + 1}: Flow=${midFlow.toFixed(1)}%, FDT=${midFDT.toFixed(1)}¬∞C, Error=${(midFDT - targetFDT).toFixed(1)}¬∞C`);
                        }
                        
                        achievedFDT = midFDT;
                        
                        if (Math.abs(midFDT - targetFDT) <= tolerance) {
                            console.log(`‚úì Converged: Flow=${midFlow.toFixed(1)}%, FDT=${midFDT.toFixed(1)}¬∞C`);
                            optimalFlow = midFlow;
                            break;
                        }
                        
                        // Higher spray = lower FDT
                        if (midFDT > targetFDT) {
                            lowFlow = midFlow;
                        } else {
                            highFlow = midFlow;
                        }
                        
                        if (highFlow - lowFlow < 0.5) {
                            optimalFlow = (lowFlow + highFlow) / 2;
                            console.log(`Range narrowed: Flow=${optimalFlow.toFixed(1)}%, FDT=${achievedFDT.toFixed(1)}¬∞C`);
                            break;
                        }
                    }
                }
                
                // Apply UNIFORM flow to all zones (no distribution - this matches what was calculated)
                const spraySettings = [];
                for (let i = 0; i < numZones; i++) {
                    spraySettings.push(optimalFlow);
                    CoolingSystem.sprays[i].flowSetpoint = optimalFlow;
                    CoolingSystem.sprays[i].actualFlow = optimalFlow;
                }
                
                console.log(`=== ISC OPTIMIZATION END ===`);
                console.log(`Result: All zones at ${optimalFlow.toFixed(0)}%, Expected FDT=${achievedFDT.toFixed(0)}¬∞C`);
                
                return spraySettings;
            }
        };
        
        // ============================================================
        // MATERIAL DATABASE
        // ============================================================
        const MaterialDatabase = {
            // Flow stress coefficients: œÉ = A * exp(m1*T) * Œµ^m2 * ŒµÃá^m3
            // Hansel-Spittel model parameters for electrical steels
            grades: {
                // Non-Oriented Normal Grades
                '50W800': {
                    type: 'NO', grade: 'Normal', Si: 0.5, Al: 0.3,
                    A: 3850, m1: -0.00285, m2: 0.145, m3: 0.125, m4: -0.045,
                    Cp: 620, k: 28, rho: 7750, Tmelt: 1520,
                    targetFDT: { min: 860, max: 920 }
                },
                '50W600': {
                    type: 'NO', grade: 'Normal', Si: 1.0, Al: 0.4,
                    A: 4150, m1: -0.00295, m2: 0.155, m3: 0.130, m4: -0.048,
                    Cp: 615, k: 26, rho: 7720, Tmelt: 1515,
                    targetFDT: { min: 855, max: 915 }
                },
                '50W470': {
                    type: 'NO', grade: 'Normal', Si: 1.5, Al: 0.5,
                    A: 4450, m1: -0.00305, m2: 0.165, m3: 0.135, m4: -0.050,
                    Cp: 610, k: 24, rho: 7690, Tmelt: 1510,
                    targetFDT: { min: 850, max: 910 }
                },
                // Non-Oriented High Grades
                '35W360': {
                    type: 'NO', grade: 'High', Si: 2.0, Al: 0.6,
                    A: 4850, m1: -0.00320, m2: 0.175, m3: 0.140, m4: -0.052,
                    Cp: 600, k: 22, rho: 7650, Tmelt: 1500,
                    targetFDT: { min: 865, max: 920 }
                },
                '35W300': {
                    type: 'NO', grade: 'High', Si: 2.5, Al: 0.7,
                    A: 5250, m1: -0.00335, m2: 0.185, m3: 0.145, m4: -0.055,
                    Cp: 590, k: 20, rho: 7620, Tmelt: 1495,
                    targetFDT: { min: 870, max: 930 }
                },
                '35W270': {
                    type: 'NO', grade: 'High', Si: 2.8, Al: 0.75,
                    A: 5550, m1: -0.00345, m2: 0.190, m3: 0.148, m4: -0.057,
                    Cp: 585, k: 19, rho: 7600, Tmelt: 1490,
                    targetFDT: { min: 875, max: 935 }
                },
                // Non-Oriented Premium Grades
                '30W250': {
                    type: 'NO', grade: 'Premium', Si: 3.0, Al: 0.8,
                    A: 5850, m1: -0.00355, m2: 0.195, m3: 0.150, m4: -0.060,
                    Cp: 580, k: 18, rho: 7580, Tmelt: 1485,
                    targetFDT: { min: 880, max: 940 }
                },
                '27W230': {
                    type: 'NO', grade: 'Premium', Si: 3.2, Al: 0.85,
                    A: 6150, m1: -0.00365, m2: 0.200, m3: 0.152, m4: -0.062,
                    Cp: 575, k: 17, rho: 7560, Tmelt: 1480,
                    targetFDT: { min: 885, max: 945 }
                },
                '23W200': {
                    type: 'NO', grade: 'Premium', Si: 3.5, Al: 0.9,
                    A: 6550, m1: -0.00380, m2: 0.210, m3: 0.155, m4: -0.065,
                    Cp: 570, k: 16, rho: 7540, Tmelt: 1475,
                    targetFDT: { min: 890, max: 950 }
                },
                // Grain-Oriented Grades
                'GO_Normal': {
                    type: 'GO', grade: 'Normal', Si: 3.0, Al: 0.02,
                    A: 5950, m1: -0.00360, m2: 0.198, m3: 0.152, m4: -0.061,
                    Cp: 575, k: 17.5, rho: 7570, Tmelt: 1482,
                    targetFDT: { min: 900, max: 960 }
                },
                'GO_High': {
                    type: 'GO', grade: 'High', Si: 3.2, Al: 0.025,
                    A: 6250, m1: -0.00370, m2: 0.205, m3: 0.155, m4: -0.063,
                    Cp: 572, k: 17, rho: 7555, Tmelt: 1478,
                    targetFDT: { min: 910, max: 970 }
                },
                'GO_Premium': {
                    type: 'GO', grade: 'Premium', Si: 3.4, Al: 0.028,
                    A: 6650, m1: -0.00385, m2: 0.215, m3: 0.158, m4: -0.066,
                    Cp: 568, k: 16.5, rho: 7535, Tmelt: 1472,
                    targetFDT: { min: 920, max: 980 }
                }
            },
            
            // Get flow stress using Hansel-Spittel equation
            getFlowStress: function(gradeKey, T, strain, strainRate) {
                const mat = this.grades[gradeKey];
                if (!mat) return 200; // Default fallback
                
                // Convert temperature to Kelvin for calculation
                const T_C = Math.max(T, 700); // Minimum 700¬∞C
                
                // Hansel-Spittel: œÉ = A * exp(m1*T) * Œµ^m2 * ŒµÃá^m3 * exp(m4/Œµ)
                const eps = Math.max(strain, 0.01);
                const epsRate = Math.max(strainRate, 0.1);
                
                let sigma = mat.A * Math.exp(mat.m1 * T_C) * 
                           Math.pow(eps, mat.m2) * 
                           Math.pow(epsRate, mat.m3) *
                           Math.exp(mat.m4 / eps);
                
                // Clamp to reasonable range (MPa)
                return Math.min(Math.max(sigma, 50), 500);
            },
            
            // Get thermal properties
            getThermalProps: function(gradeKey) {
                const mat = this.grades[gradeKey];
                return {
                    Cp: mat.Cp,  // J/(kg¬∑K)
                    k: mat.k,    // W/(m¬∑K)
                    rho: mat.rho // kg/m¬≥
                };
            }
        };
        
        // ============================================================
        // MILL CONFIGURATION
        // ============================================================
        const MillConfig = {
            numStands: 7,
            stands: [],
            loopers: [],
            
            init: function() {
                // Initialize 7 stands (F1-F7)
                const workRollDiameters = [720, 700, 680, 660, 650, 640, 630]; // mm
                const backupRollDiameters = [1400, 1400, 1380, 1380, 1360, 1360, 1350]; // mm
                const motorPowers = [8000, 8000, 7500, 7000, 6500, 6000, 5500]; // kW
                const maxForces = [35, 35, 32, 30, 28, 26, 24]; // MN
                
                for (let i = 0; i < this.numStands; i++) {
                    this.stands.push({
                        id: i + 1,
                        name: `F${i + 1}`,
                        workRollDia: workRollDiameters[i],
                        backupRollDia: backupRollDiameters[i],
                        barrelLength: 2200, // mm
                        millModulus: 4500 + i * 200, // MN/m (increases for downstream stands)
                        motorPower: motorPowers[i],
                        maxForce: maxForces[i],
                        maxBendingForce: 1500, // kN
                        maxCVCShift: 100, // mm
                        agcGain: 0.6 - i * 0.03,
                        hydraulicResponse: 0.015, // seconds
                        // Operating parameters (will be updated during simulation)
                        rollGap: 20,
                        speedSetpoint: 1.0,
                        bendingForce: 500,
                        cvcShift: 0,
                        pairCrossAngle: 0,
                        // Measured values
                        force: 0,
                        torque: 0,
                        power: 0,
                        reduction: 0,
                        entryH: 0,
                        exitH: 0,
                        entryT: 0,
                        exitT: 0,
                        speed: 0,
                        rollSpeed: 0,
                        contactLength: 0,
                        backTension: 0,    // MPa - tension on entry side
                        frontTension: 0,   // MPa - tension on exit side
                        // Shape parameters
                        crown: 0,          // mm - strip crown
                        flatness: 0,       // I-units - flatness index
                        wedge: 0           // Œºm - thickness difference across width
                    });
                }
                
                // Initialize 6 loopers (between stands)
                // Tension typically increases from entry to exit
                const tensionSetpoints = [10, 12, 14, 16, 18, 20]; // MPa
                
                for (let i = 0; i < this.numStands - 1; i++) {
                    this.loopers.push({
                        id: i + 1,
                        name: `L${i + 1}-${i + 2}`,
                        type: 'electric',
                        armLength: 400, // mm
                        nominalAngle: 25, // degrees
                        minAngle: 5,
                        maxAngle: 45,
                        motorTorque: 2000, // Nm
                        inertia: 50, // kg¬∑m¬≤
                        // Operating parameters
                        angleSetpoint: 25,
                        tensionSetpoint: tensionSetpoints[i], // MPa - varies by position
                        // Measured values
                        angle: 25,
                        tension: tensionSetpoints[i],
                        loopHeight: 0
                    });
                }
            }
        };
        
        // ============================================================
        // PHYSICAL MODELS
        // ============================================================
        const PhysicsModels = {
            // Rolling force using Sims' model with modifications
            calculateRollingForce: function(stand, material, entryH, exitH, width, temp, speed) {
                const R = stand.workRollDia / 2; // mm
                const h_avg = (entryH + exitH) / 2;
                const reduction = (entryH - exitH) / entryH;
                const strain = Math.log(entryH / exitH);
                const contactLength = Math.sqrt(R * (entryH - exitH));
                
                // Strain rate (1/s)
                const strainRate = (speed * 1000) / contactLength * strain;
                
                // Get flow stress
                const sigma = MaterialDatabase.getFlowStress(material, temp, strain, strainRate);
                
                // Sims geometry factor
                const Qp = this.simsQpFactor(R / 1000, entryH / 1000, exitH / 1000);
                
                // Calculate force (MN)
                const force = (sigma * width * contactLength * Qp) / 1e6;
                
                return {
                    force: Math.min(force, stand.maxForce),
                    contactLength: contactLength,
                    strain: strain,
                    strainRate: strainRate,
                    flowStress: sigma
                };
            },
            
            simsQpFactor: function(R, h1, h2) {
                // Sims' Qp factor for force calculation
                const r = (h1 - h2) / h1;
                const h_bar = (h1 + h2) / 2;
                const ratio = Math.sqrt(R / h_bar);
                
                // Approximate Qp
                let Qp = 0.8 + 0.2 * Math.sqrt(r);
                if (ratio > 2) {
                    Qp *= 1 + 0.1 * (ratio - 2);
                }
                return Math.min(Qp, 1.4);
            },
            
            // Rolling torque
            calculateTorque: function(force, contactLength, workRollDia) {
                // Torque per roll (kNm)
                // force is in MN, contactLength is in mm
                // Lever arm is approximately 0.4-0.5 of contact length
                const leverArm_mm = contactLength * 0.45;
                // Torque = Force √ó Lever arm
                // Force (MN) √ó leverArm (mm) = MN¬∑mm = kN¬∑m = kNm
                const torquePerRoll = force * leverArm_mm;
                // Two work rolls, so total torque is 2x
                const totalTorque = torquePerRoll * 2;
                return totalTorque;
            },
            
            // Motor power
            calculatePower: function(torque, speed, workRollDia) {
                // torque is in kNm, speed is in m/s, workRollDia is in mm
                // Angular velocity (rad/s) = linear speed / radius
                const radius_m = workRollDia / 2 / 1000; // Convert mm to m
                const omega = speed / radius_m; // rad/s
                // Power (MW) = Torque (kNm) √ó omega (rad/s) / 1000
                const power = (torque * omega) / 1000;
                return power;
            },
            
            // Temperature change through stand
            calculateTemperatureChange: function(material, entryH, exitH, entryTemp, force, width, contactLength, speed) {
                const thermal = MaterialDatabase.getThermalProps(material);
                const strain = Math.log(entryH / exitH);
                const h_avg = (entryH + exitH) / 2;
                
                // Deformation heating - 95% of plastic work converts to heat
                // Typical: 15-40¬∞C rise per stand depending on reduction
                const flowStress = MaterialDatabase.getFlowStress(material, entryTemp, strain, 10);
                const deformWork = flowStress * strain * 1e6; // J/m¬≥
                const volume = width * h_avg * contactLength / 1e9; // m¬≥
                const mass = volume * thermal.rho;
                const dT_deform = (deformWork * volume * 0.95) / (mass * thermal.Cp);
                
                // Roll cooling - reduced (rolls are cooled but contact time is short)
                // Typical: 5-15¬∞C loss to rolls per stand
                const contactTime = contactLength / (speed * 1000);
                const rollTemp = 80; // ¬∞C, work rolls warm up during rolling
                const heatTransfer = 5000; // W/(m¬≤¬∑K) - reduced for thin oxide layer
                const contactArea = 2 * width * contactLength / 1e6; // m¬≤
                const dT_roll = (heatTransfer * contactArea * contactTime * (entryTemp - rollTemp)) / 
                               (mass * thermal.Cp);
                
                // Net is typically positive (deformation heating > roll cooling)
                // Typical net: +5 to +25¬∞C per stand
                return {
                    deformHeating: dT_deform,
                    rollCooling: -dT_roll * 0.15, // Reduced - oxide layer insulation
                    netChange: dT_deform - dT_roll * 0.15
                };
            },
            
            // Inter-stand temperature loss (radiation + convection, NO spray)
            calculateInterstandTempLoss: function(material, thickness, temp, distance, speed) {
                const thermal = MaterialDatabase.getThermalProps(material);
                const time = distance / (speed * 1000); // seconds
                
                // Radiation loss (Stefan-Boltzmann) - reduced due to hot mill environment
                const emissivity = 0.65; // Lower due to scale, steam, hot surroundings
                const sigma = 5.67e-8;
                const T_K = temp + 273.15;
                const T_amb = 100 + 273.15; // Hot mill ambient ~100¬∞C (radiation from nearby equipment)
                const qRad = emissivity * sigma * (Math.pow(T_K, 4) - Math.pow(T_amb, 4));
                
                // Convection loss - reduced (stagnant hot air)
                const h_conv = 8; // W/(m¬≤¬∑K) - low in enclosed mill area
                const qConv = h_conv * (temp - 100);
                
                // Total heat loss rate per unit area (W/m¬≤)
                const qTotal = qRad + qConv;
                
                // Temperature drop - apply 60% factor (deformation reheating offsets some loss)
                const dT = (2 * qTotal * time) / (thermal.rho * thermal.Cp * thickness / 1000);
                
                return -dT * 0.6; // 60% of calculated - hot mill environment
            },
            
            // Mill spring equation: h_actual = S + P/M
            calculateActualGauge: function(rollGap, force, millModulus) {
                // force in MN, millModulus in MN/m, rollGap in mm
                const stretch = (force * 1000) / millModulus; // mm
                return rollGap + stretch;
            },
            
            // Crown calculation
            calculateCrown: function(stand, force, width, bendingForce, cvcShift, thermalCrown, standIndex) {
                // Mechanical crown from force (negative = thinner at center)
                // Higher force causes roll deflection -> negative crown
                // Force effect is stronger on upstream stands with higher forces
                const forceCrown = -0.025 * force * Math.pow(width / 1000, 2);
                
                // Bending effect (positive bending = thicker at center)
                const bendingCrown = 0.008 * bendingForce * Math.pow(width / 1000, 2);
                
                // CVC effect (crown control with shifted rolls)
                // Typical CVC provides ~3 Œºm crown change per 10mm shift
                const cvcCrown = 0.25 * cvcShift * (width / 1000);
                
                // Thermal crown (from work roll heating) - varies by stand and time
                // Upstream stands have more thermal crown due to higher forces
                const standFactor = 1.0 - (standIndex || 0) * 0.08; // F1=1.0, F7=0.44
                const baseThermal = 12 * standFactor; // 8-12 Œºm base
                const thermal = baseThermal + (thermalCrown || 0);
                
                // Random disturbance (roll eccentricity, thickness variation)
                const disturbance = (Math.random() - 0.5) * 2; // ¬±1 Œºm
                
                // Total crown (Œºm)
                return forceCrown + bendingCrown + cvcCrown + thermal + disturbance;
            },
            
            // Looper dynamics
            calculateLooperDynamics: function(looper, upstreamSpeed, downstreamSpeed, tension, thickness, width) {
                // Looper angle control:
                // The looper maintains a constant angle setpoint through motor torque control
                // In practice, the angle is very tightly controlled with fast response
                
                // Speed ratio determines strip accumulation rate (minor effect)
                const speedRatio = upstreamSpeed / Math.max(0.01, downstreamSpeed);
                
                // Angle perturbation from speed mismatch (small effect)
                const anglePerturbation = (speedRatio - 1) * 5; // Small perturbation
                
                // Strong PI control to maintain setpoint (fast looper response)
                const angleError = looper.angleSetpoint - looper.angle;
                
                // Looper motors are fast - high gain control
                // New angle = current + strong correction toward setpoint + small perturbation + noise
                let newAngle = looper.angle + angleError * 0.5 + anglePerturbation + (Math.random() - 0.5) * 0.5;
                newAngle = Math.max(looper.minAngle, Math.min(looper.maxAngle, newAngle));
                
                // Loop height from angle
                const loopHeight = looper.armLength * Math.sin(newAngle * Math.PI / 180);
                
                return {
                    angle: newAngle,
                    loopHeight: loopHeight,
                    tensionError: tension - looper.tensionSetpoint
                };
            }
        };
        
        // ============================================================
        // CONTROL SYSTEMS
        // ============================================================
        const ControlSystems = {
            // PID controller class
            PIDController: class {
                constructor(Kp, Ki, Kd, minOut, maxOut) {
                    this.Kp = Kp;
                    this.Ki = Ki;
                    this.Kd = Kd;
                    this.minOut = minOut;
                    this.maxOut = maxOut;
                    this.integral = 0;
                    this.prevError = 0;
                    this.prevOutput = 0;
                }
                
                compute(setpoint, measured, dt) {
                    const error = setpoint - measured;
                    
                    // Proportional
                    const P = this.Kp * error;
                    
                    // Integral with anti-windup
                    this.integral += error * dt;
                    this.integral = Math.max(-100, Math.min(100, this.integral));
                    const I = this.Ki * this.integral;
                    
                    // Derivative with filtering
                    const derivative = (error - this.prevError) / dt;
                    const D = this.Kd * derivative;
                    
                    this.prevError = error;
                    
                    // Output with limits
                    let output = P + I + D;
                    output = Math.max(this.minOut, Math.min(this.maxOut, output));
                    
                    // Rate limiting
                    const maxRate = 5; // mm/s for AGC
                    const rate = (output - this.prevOutput) / dt;
                    if (Math.abs(rate) > maxRate) {
                        output = this.prevOutput + Math.sign(rate) * maxRate * dt;
                    }
                    
                    this.prevOutput = output;
                    return output;
                }
                
                reset() {
                    this.integral = 0;
                    this.prevError = 0;
                    this.prevOutput = 0;
                }
            },
            
            agcControllers: [],
            looperAngleControllers: [],
            looperTensionControllers: [],
            tempController: null,
            crownControllers: [],
            
            init: function() {
                // Initialize AGC controllers for each stand
                for (let i = 0; i < MillConfig.numStands; i++) {
                    this.agcControllers.push(new this.PIDController(
                        0.8 - i * 0.05,  // Kp decreases downstream
                        0.15,             // Ki
                        0.02,             // Kd
                        -2,               // min output (mm)
                        2                 // max output (mm)
                    ));
                    
                    this.crownControllers.push(new this.PIDController(
                        0.5, 0.1, 0.01, -500, 500
                    ));
                }
                
                // Looper controllers
                for (let i = 0; i < MillConfig.numStands - 1; i++) {
                    this.looperAngleControllers.push(new this.PIDController(
                        2.0, 0.5, 0.1, -0.05, 0.05  // Speed ratio adjustment
                    ));
                    this.looperTensionControllers.push(new this.PIDController(
                        0.3, 0.1, 0.02, -100, 100   // Looper torque adjustment
                    ));
                }
                
                // Temperature controller
                this.tempController = new this.PIDController(
                    0.1, 0.02, 0.005, 0.9, 1.1  // Speed multiplier
                );
            },
            
            // Feedforward AGC
            feedforwardAGC: function(standIndex, entryThicknessDeviation, millModulus) {
                if (!document.getElementById('agcFF').checked) return 0;
                
                // Compensate for incoming thickness deviation
                const gain = MillConfig.stands[standIndex].agcGain;
                return -gain * entryThicknessDeviation;
            },
            
            // Monitor AGC
            monitorAGC: function(standIndex, targetThickness, measuredThickness, dt) {
                if (!document.getElementById('agcMon').checked) return 0;
                
                return this.agcControllers[standIndex].compute(targetThickness, measuredThickness, dt);
            },
            
            // Mass Flow AGC
            massFlowAGC: function(standIndex, upstreamH, upstreamV, currentH, currentV) {
                if (!document.getElementById('agcMF').checked) return 0;
                if (standIndex === 0) return 0;
                
                // Mass flow: h1*v1 = h2*v2
                const upstreamMassFlow = upstreamH * upstreamV;
                const currentMassFlow = currentH * currentV;
                const error = (upstreamMassFlow - currentMassFlow) / currentMassFlow;
                
                // Small correction to speed
                return error * 0.01;
            },
            
            // Looper control
            looperControl: function(looperIndex, angle, angleSetpoint, tension, tensionSetpoint, dt) {
                if (!document.getElementById('looperCtrl').checked) {
                    return { speedAdj: 0, torqueAdj: 0 };
                }
                
                // Angle control affects downstream stand speed
                const speedAdj = this.looperAngleControllers[looperIndex].compute(angleSetpoint, angle, dt);
                
                // Tension control affects looper torque
                const torqueAdj = this.looperTensionControllers[looperIndex].compute(tensionSetpoint, tension, dt);
                
                return { speedAdj, torqueAdj };
            },
            
            // Temperature control (affects mill speed)
            temperatureControl: function(targetFDT, measuredFDT, dt) {
                if (!document.getElementById('tempCtrl').checked) return 1.0;
                
                return this.tempController.compute(targetFDT, measuredFDT, dt);
            },
            
            // Crown control
            crownControl: function(standIndex, targetCrown, measuredCrown, dt) {
                if (!document.getElementById('crownCtrl').checked) return 0;
                
                return this.crownControllers[standIndex].compute(targetCrown, measuredCrown, dt);
            },
            
            reset: function() {
                this.agcControllers.forEach(c => c.reset());
                this.looperAngleControllers.forEach(c => c.reset());
                this.looperTensionControllers.forEach(c => c.reset());
                this.crownControllers.forEach(c => c.reset());
                if (this.tempController) this.tempController.reset();
            }
        };
        
        // ============================================================
        // SIMULATION ENGINE
        // ============================================================
        const SimulationEngine = {
            isRunning: false,
            isPaused: false,
            simTime: 0,
            dt: 0.01, // 10ms timestep
            animationFrame: null,
            lastFrameTime: 0,
            frameCount: 0,
            fps: 60,
            
            // Strip state
            strip: {
                material: '50W800',
                entryThickness: 32,
                targetExitThickness: 2.0,
                width: 1250,
                entryTemperature: 1050,
                length: 800, // meters
                position: 0,
                currentThickness: 32,
                currentTemperature: 1050,
                exitThickness: 2.0,
                exitTemperature: 880
            },
            
            // Schedule
            schedule: {
                thicknesses: [],
                reductions: [],
                speeds: [],
                rollSpeeds: [],
                forces: [],
                torques: [],
                powers: [],
                temperatures: []
            },
            
            // History for trends
            history: {
                time: [],
                // Per-stand history arrays
                stands: {
                    thickness: [[], [], [], [], [], [], []], // F1-F7
                    temperature: [[], [], [], [], [], [], []],
                    force: [[], [], [], [], [], [], []],
                    speed: [[], [], [], [], [], [], []],
                    power: [[], [], [], [], [], [], []]
                },
                // Looper tensions (6 loopers)
                tension: [[], [], [], [], [], []],
                // Looper angles (6 loopers)
                looperAngle: [[], [], [], [], [], []],
                // Zone temperatures (6 ISC zones + entry + exit = 8 points)
                zoneTemp: [[], [], [], [], [], [], [], []],
                maxLength: 300
            },
            
            init: function() {
                MillConfig.init();
                ControlSystems.init();
                CoolingSystem.init();
                this.calculateSchedule();
                
                // Verify schedule was calculated correctly
                console.log('=== INIT VERIFICATION ===');
                console.log('Target exit thickness:', this.strip.targetExitThickness);
                console.log('Schedule thicknesses:', this.schedule.thicknesses);
                console.log('F7 stand.exitH:', MillConfig.stands[6].exitH);
                console.log('F7 stand.rollGap:', MillConfig.stands[6].rollGap);
                
                this.initUI();
            },
            
            calculateSchedule: function() {
                try {
                    // Get input values with defaults
                    const entryEl = document.getElementById('entryThickness');
                    const exitEl = document.getElementById('exitThickness');
                    const widthEl = document.getElementById('stripWidth');
                    const tempEl = document.getElementById('entryTemp');
                    const gradeEl = document.getElementById('steelGrade');
                    const reductionLawEl = document.getElementById('reductionLaw');
                    
                    const H0 = entryEl ? parseFloat(entryEl.value) || 32 : this.strip.entryThickness;
                    const Hf = exitEl ? parseFloat(exitEl.value) || 2.0 : this.strip.targetExitThickness;
                    const W = widthEl ? parseFloat(widthEl.value) || 1250 : this.strip.width;
                    const T0 = tempEl ? parseFloat(tempEl.value) || 1050 : this.strip.entryTemperature;
                    const material = (gradeEl && gradeEl.value) ? gradeEl.value : '50W800';
                    const reductionLaw = reductionLawEl ? reductionLawEl.value : 'frontLoaded';
                    
                    console.log('=== Schedule Calculation ===');
                    console.log('Input:', { H0, Hf, W, T0, material, reductionLaw });
                    
                    this.strip.material = material;
                    this.strip.entryThickness = H0;
                    this.strip.targetExitThickness = Hf;
                    this.strip.currentThickness = H0;
                    this.strip.width = W;
                    this.strip.entryTemperature = T0;
                    this.strip.currentTemperature = T0;
                
                    const numStands = MillConfig.numStands;
                    
                    // ========================================
                    // STRAIN-BASED THICKNESS DISTRIBUTION
                    // ========================================
                    // Total true strain: Œµ_total = ln(H0/Hf)
                    // Distribute strain by weights: Œµi = wi * Œµ_total / Œ£w
                    // Exit thickness: Hi = H(i-1) * exp(-Œµi)
                    // This GUARANTEES: H_final = H0 * exp(-Œ£Œµi) = H0 * exp(-Œµ_total) = Hf
                    
                    const totalStrain = Math.log(H0 / Hf);
                    console.log('Total strain:', totalStrain.toFixed(4), '(ln(' + H0 + '/' + Hf + '))');
                    
                    // Get distribution weights
                    const weights = this.getReductionPattern(reductionLaw, numStands);
                    const sumWeights = weights.reduce((a, b) => a + b, 0);
                    const normalizedWeights = weights.map(w => w / sumWeights);
                    
                    console.log('Distribution weights:', normalizedWeights.map(w => (w * 100).toFixed(1) + '%'));
                    
                    // Calculate strain per stand
                    const strainPerStand = normalizedWeights.map(w => w * totalStrain);
                    console.log('Strain per stand:', strainPerStand.map(s => s.toFixed(4)));
                    
                    // Calculate thicknesses
                    const thicknesses = [H0];
                    let currentH = H0;
                    for (let i = 0; i < numStands; i++) {
                        // Hi = H(i-1) * exp(-Œµi)
                        const exitH = currentH * Math.exp(-strainPerStand[i]);
                        thicknesses.push(exitH);
                        currentH = exitH;
                    }
                    
                    // Force final thickness to EXACTLY match target (eliminate floating point error)
                    thicknesses[numStands] = Hf;
                    
                    console.log('========================================');
                    console.log('THICKNESS VERIFICATION:');
                    console.log('Entry H0 =', H0, 'mm');
                    console.log('Target Hf =', Hf, 'mm');
                    console.log('Total strain = ln(' + H0 + '/' + Hf + ') =', totalStrain.toFixed(4));
                    console.log('Calculated thicknesses:', thicknesses.map(t => t.toFixed(4)));
                    console.log('F7 exit (should equal target):', thicknesses[7], '===', Hf, '?', thicknesses[7] === Hf);
                    console.log('========================================');
                    
                    // ========================================
                    // CALCULATE PROCESS PARAMETERS
                    // ========================================
                    let currentT = T0;
                    const baseSpeed = 3.5; // m/s at F7 exit
                    
                    // Initialize schedule arrays
                    this.schedule.thicknesses = [H0];
                    this.schedule.reductions = [];
                    this.schedule.speeds = [];
                    this.schedule.rollSpeeds = [];
                    this.schedule.forces = [];
                    this.schedule.torques = [];
                    this.schedule.powers = [];
                    this.schedule.temperatures = [T0];
                    
                    currentH = H0;
                    
                    for (let i = 0; i < numStands; i++) {
                        const entryH = currentH;
                        const exitH = thicknesses[i + 1];
                        const reduction = (entryH - exitH) / entryH;
                        
                        // Strip speed from mass flow conservation
                        // At F7 exit: speed = baseSpeed, thickness = Hf
                        // V * H = constant, so V = baseSpeed * Hf / H
                        const stripSpeed = baseSpeed * (Hf / exitH);
                        
                        // Roll surface speed (accounting for forward slip)
                        const forwardSlip = 0.03 + 0.02 * (1 - i / numStands);
                        const rollSpeed = stripSpeed / (1 + forwardSlip);
                        
                        // Rolling force
                        const forceResult = PhysicsModels.calculateRollingForce(
                            MillConfig.stands[i], material, entryH, exitH, W, currentT, stripSpeed
                        );
                        
                        // Torque and power
                        const torque = PhysicsModels.calculateTorque(
                            forceResult.force, forceResult.contactLength, MillConfig.stands[i].workRollDia
                        );
                        const power = PhysicsModels.calculatePower(
                            torque, stripSpeed, MillConfig.stands[i].workRollDia
                        );
                        
                        // Temperature change
                        const tempChange = PhysicsModels.calculateTemperatureChange(
                            material, entryH, exitH, currentT, forceResult.force, W, 
                            forceResult.contactLength, stripSpeed
                        );
                        
                        // Inter-stand cooling
                        const interstandLoss = i < numStands - 1 ? 
                            PhysicsModels.calculateInterstandTempLoss(material, exitH, currentT, 5000, stripSpeed) : 0;
                        
                        const exitT = currentT + tempChange.netChange + interstandLoss;
                        
                        // Store schedule
                        this.schedule.thicknesses.push(exitH);
                        this.schedule.reductions.push(reduction);
                        this.schedule.speeds.push(stripSpeed);
                        this.schedule.rollSpeeds.push(rollSpeed);
                        this.schedule.forces.push(forceResult.force);
                        this.schedule.torques.push(torque);
                        this.schedule.powers.push(power);
                        this.schedule.temperatures.push(exitT);
                        
                        // Update stand
                        const stand = MillConfig.stands[i];
                        stand.rollGap = exitH;
                        stand.speedSetpoint = stripSpeed / baseSpeed;
                        stand.entryH = entryH;
                        stand.exitH = exitH;
                        stand.entryT = currentT;
                        stand.exitT = exitT;
                        stand.force = forceResult.force;
                        stand.torque = torque;
                        stand.power = power;
                        stand.speed = stripSpeed;
                        stand.rollSpeed = rollSpeed;
                        stand.reduction = reduction;
                        stand.contactLength = forceResult.contactLength;
                        
                        // Set initial tensions from looper setpoints
                        // Back tension = previous looper (or entry tension for F1)
                        // Front tension = next looper (or coiler tension for F7)
                        if (i === 0) {
                            stand.backTension = 5;  // Entry tension from rougher
                        } else {
                            stand.backTension = MillConfig.loopers[i - 1].tensionSetpoint;
                        }
                        if (i === numStands - 1) {
                            stand.frontTension = 20;  // Coiler tension
                        } else {
                            stand.frontTension = MillConfig.loopers[i].tensionSetpoint;
                        }
                        
                        // Initialize bending force for approximate target crown
                        // Target crowns decrease from F1 to F7
                        const targetCrowns = [30, 28, 25, 22, 20, 18, 15]; // Œºm
                        const targetCrown = targetCrowns[i];
                        const standFactor = 1.0 - i * 0.08;
                        const baseThermal = 12 * standFactor; // Varies by stand
                        const forceCrown = -0.025 * forceResult.force * Math.pow(W / 1000, 2);
                        // Required crown from bending (assuming CVC = 0 initially)
                        const requiredBendingCrown = targetCrown - baseThermal - forceCrown;
                        // Use coefficient 0.008 to match calculateCrown
                        const requiredBending = requiredBendingCrown / (0.008 * Math.pow(W / 1000, 2));
                        // Start at 100% of required - let controller fine-tune
                        stand.bendingForce = Math.max(-1500, Math.min(1500, requiredBending));
                        // Start CVC at small positive value to help achieve target
                        stand.cvcShift = 5; // Start with small positive CVC
                        stand.thermalCrown = 0; // Initialize thermal crown tracking
                        stand.crownIntegral = 0; // Initialize crown control integral
                        
                        console.log(`F${i+1}: ${entryH.toFixed(3)}‚Üí${exitH.toFixed(3)} mm (${(reduction*100).toFixed(1)}%), ` +
                                    `Force=${forceResult.force.toFixed(1)} MN, Torque=${torque.toFixed(0)} kNm, Power=${power.toFixed(2)} MW, ` +
                                    `Bending=${stand.bendingForce.toFixed(0)} kN, Target Crown=${targetCrown} Œºm`);
                        
                        currentH = exitH;
                        currentT = exitT;
                    }
                    
                    this.strip.exitThickness = this.schedule.thicknesses[numStands];
                    this.strip.exitTemperature = currentT;
                    
                    console.log('=== Schedule Complete ===');
                    console.log('Entry:', H0.toFixed(3), 'mm ‚Üí Exit:', this.strip.exitThickness.toFixed(3), 'mm (Target:', Hf.toFixed(3), 'mm)');
                    console.log('Total Power:', this.schedule.powers.reduce((a,b) => a+b, 0).toFixed(2), 'MW');
                    
                    // Verify stand values
                    console.log('=== STAND VALUES AFTER SCHEDULE ===');
                    for (let i = 0; i < numStands; i++) {
                        const s = MillConfig.stands[i];
                        console.log(`F${i+1}: exitH=${s.exitH.toFixed(3)}, rollGap=${s.rollGap.toFixed(3)}, target=${thicknesses[i+1].toFixed(3)}`);
                    }
                    
                    // Update UI
                    this.updateScheduleDisplay();
                    
                } catch (error) {
                    console.error('Error calculating schedule:', error);
                }
            },
            
            // Get reduction pattern based on selected reduction law
            getReductionPattern: function(law, numStands) {
                switch (law) {
                    case 'balanced':
                        // Equal reduction per stand (geometric mean)
                        return Array(numStands).fill(1.0);
                        
                    case 'frontLoaded':
                        // Higher reduction in early stands (traditional for electrical steel)
                        // Decreasing pattern: 45%, 40%, 35%, 30%, 25%, 20%, 15%
                        return [0.45, 0.40, 0.35, 0.30, 0.25, 0.20, 0.15];
                        
                    case 'backLoaded':
                        // Higher reduction in later stands
                        return [0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45];
                        
                    case 'exponentialDecay':
                        // Exponential decay pattern: each stand gets 0.8x the previous
                        const expPattern = [];
                        for (let i = 0; i < numStands; i++) {
                            expPattern.push(Math.pow(0.8, i));
                        }
                        return expPattern;
                        
                    case 'exponentialGrowth':
                        // Exponential growth pattern
                        const expGrowth = [];
                        for (let i = 0; i < numStands; i++) {
                            expGrowth.push(Math.pow(1.15, i));
                        }
                        return expGrowth;
                        
                    case 'parabolic':
                        // Parabolic pattern - higher in middle stands
                        const paraPattern = [];
                        const mid = (numStands - 1) / 2;
                        for (let i = 0; i < numStands; i++) {
                            const dist = Math.abs(i - mid);
                            paraPattern.push(1.0 - 0.15 * dist);
                        }
                        return paraPattern;
                        
                    case 'sinusoidal':
                        // Sinusoidal pattern - smooth transition
                        const sinPattern = [];
                        for (let i = 0; i < numStands; i++) {
                            sinPattern.push(1 + 0.3 * Math.sin(Math.PI * i / (numStands - 1)));
                        }
                        return sinPattern;
                        
                    case 'tandem':
                        // Tandem mill pattern - alternating high/low
                        return [0.40, 0.30, 0.38, 0.28, 0.35, 0.25, 0.20];
                        
                    case 'thermal':
                        // Thermally optimized - higher reduction while hot
                        return [0.50, 0.45, 0.38, 0.30, 0.22, 0.18, 0.12];
                        
                    default:
                        return [0.45, 0.40, 0.35, 0.30, 0.25, 0.20, 0.15];
                }
            },
            
            updateScheduleDisplay: function() {
                console.log('Updating schedule display, thicknesses:', this.schedule.thicknesses);
                
                // Validate schedule data
                if (!this.schedule.thicknesses || this.schedule.thicknesses.length < 8) {
                    console.warn('Schedule data incomplete');
                    return;
                }
                
                // Total reduction
                const totalRed = (1 - this.schedule.thicknesses[7] / this.schedule.thicknesses[0]) * 100;
                const totalRedEl = document.getElementById('totalReduction');
                if (totalRedEl) totalRedEl.textContent = totalRed.toFixed(2) + '%';
                
                // Exit thickness
                const exitThickEl = document.getElementById('exitThicknessDisplay');
                if (exitThickEl) exitThickEl.textContent = this.schedule.thicknesses[7].toFixed(3) + ' mm';
                
                // Total power
                const totalPower = this.schedule.powers && this.schedule.powers.length > 0 ? 
                    this.schedule.powers.reduce((a, b) => a + b, 0) : 0;
                const estPowerEl = document.getElementById('estPowerTotal');
                if (estPowerEl) estPowerEl.textContent = totalPower.toFixed(1) + ' MW';
                
                // Exit temperature (FDT)
                const exitTemp = this.schedule.temperatures[7];
                const estFDTEl = document.getElementById('estFDT');
                if (estFDTEl) {
                    estFDTEl.textContent = exitTemp.toFixed(0) + '¬∞C';
                    const mat = MaterialDatabase.grades[this.strip.material];
                    const targetFDT = mat ? (mat.targetFDT.min + mat.targetFDT.max) / 2 : 880;
                    const fdtError = Math.abs(exitTemp - targetFDT);
                    if (fdtError < 10) {
                        estFDTEl.className = 'status-card-value success';
                    } else if (fdtError < 30) {
                        estFDTEl.className = 'status-card-value warning';
                    } else {
                        estFDTEl.className = 'status-card-value danger';
                    }
                }
                
                // Populate schedule table
                this.updateScheduleTable();
            },
            
            updateScheduleTable: function() {
                const tbody = document.getElementById('scheduleTableBody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                
                for (let i = 0; i < MillConfig.numStands; i++) {
                    const stand = MillConfig.stands[i];
                    const looper = i < MillConfig.loopers.length ? MillConfig.loopers[i] : null;
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="stand-col">${stand.name}</td>
                        <td>${stand.entryH.toFixed(2)}</td>
                        <td>${stand.exitH.toFixed(3)}</td>
                        <td>${(stand.reduction * 100).toFixed(1)}</td>
                        <td>${stand.force.toFixed(1)}</td>
                        <td>${stand.torque.toFixed(0)}</td>
                        <td>${stand.power.toFixed(2)}</td>
                        <td>${stand.speed.toFixed(2)}</td>
                        <td>${stand.exitT.toFixed(0)}</td>
                        <td>${(stand.backTension || 0).toFixed(1)} / ${(stand.frontTension || 0).toFixed(1)}</td>
                        <td>${looper ? looper.angleSetpoint.toFixed(1) : '-'}</td>
                    `;
                    tbody.appendChild(row);
                }
            },
            
            updateStandsStatusTable: function() {
                const f7Speed = MillConfig.stands[6]?.speed || 3.5;
                
                // Update Gap Control table
                const gapBody = document.getElementById('gapControlBody');
                if (gapBody) {
                    gapBody.innerHTML = '';
                    for (let i = 0; i < MillConfig.numStands; i++) {
                        const stand = MillConfig.stands[i];
                        const speedRatio = stand.speed / f7Speed;
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="stand-col">${stand.name}</td>
                            <td>${(stand.rollGap || 0).toFixed(3)}</td>
                            <td>${stand.exitH.toFixed(3)}</td>
                            <td>${(stand.speed || 0).toFixed(2)}</td>
                            <td>${speedRatio.toFixed(3)}</td>
                        `;
                        gapBody.appendChild(row);
                    }
                }
                
                // Update Shape Control table
                const shapeBody = document.getElementById('shapeControlBody');
                if (shapeBody) {
                    shapeBody.innerHTML = '';
                    const targetCrowns = [30, 28, 25, 22, 20, 18, 15]; // Œºm, F1 to F7
                    for (let i = 0; i < MillConfig.numStands; i++) {
                        const stand = MillConfig.stands[i];
                        // Calculate shape parameters
                        const crown = (stand.crown || 0) * 1000; // Convert to Œºm
                        const targetCrown = targetCrowns[i];
                        const crownError = Math.abs(crown - targetCrown);
                        const flatness = stand.flatness || 0;
                        const wedge = stand.wedge || 0;
                        
                        // Color code crown based on deviation from target
                        let crownColor = 'inherit';
                        if (crownError > 10) crownColor = 'var(--accent-red)';
                        else if (crownError > 5) crownColor = 'var(--accent-yellow)';
                        else crownColor = 'var(--accent-green)';
                        
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="stand-col">${stand.name}</td>
                            <td>${(stand.bendingForce || 0).toFixed(0)}</td>
                            <td>${(stand.cvcShift || 0).toFixed(1)}</td>
                            <td style="color:${crownColor}">${crown.toFixed(1)} <small>(${targetCrown})</small></td>
                            <td>${flatness.toFixed(1)}</td>
                            <td>${wedge.toFixed(1)}</td>
                        `;
                        shapeBody.appendChild(row);
                    }
                }
                
                // Update Force/Torque/Power table
                const statusBody = document.getElementById('standsStatusBody');
                if (statusBody) {
                    statusBody.innerHTML = '';
                    for (let i = 0; i < MillConfig.numStands; i++) {
                        const stand = MillConfig.stands[i];
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td class="stand-col">${stand.name}</td>
                            <td>${stand.force.toFixed(1)}</td>
                            <td>${(stand.torque || 0).toFixed(0)}</td>
                            <td>${(stand.power || 0).toFixed(2)}</td>
                            <td>${(stand.rollSpeed || 0).toFixed(2)}</td>
                        `;
                        statusBody.appendChild(row);
                    }
                }
            },
            
            drawSchedulePreview: function() {
                const container = document.getElementById('schedulePreviewChart');
                if (!container) {
                    // Chart container not present in current layout
                    return;
                }
                
                // Check if schedule data is available
                if (!this.schedule.reductions || this.schedule.reductions.length < 7) {
                    return;
                }
                
                // Create canvas if it doesn't exist
                let canvas = container.querySelector('canvas');
                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    container.appendChild(canvas);
                }
                
                const ctx = canvas.getContext('2d');
                
                // Get container dimensions, using style height as fallback
                let containerWidth = container.clientWidth || container.offsetWidth;
                let containerHeight = container.clientHeight || container.offsetHeight;
                
                // If container is hidden (in inactive tab), use explicit dimensions
                if (containerWidth < 50) containerWidth = 500;
                if (containerHeight < 50) containerHeight = 180;
                
                canvas.width = containerWidth;
                canvas.height = containerHeight;
                
                const w = canvas.width;
                const h = canvas.height;
                const padding = { left: 50, right: 20, top: 25, bottom: 35 };
                const chartW = w - padding.left - padding.right;
                const chartH = h - padding.top - padding.bottom;
                const barWidth = Math.max(25, chartW / 8 - 8);
                
                // Clear
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                // Draw grid lines
                ctx.strokeStyle = '#d0d7de';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (chartH / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(w - padding.right, y);
                    ctx.stroke();
                }
                
                // Draw bars for each stand reduction
                const maxReduction = Math.max(...this.schedule.reductions) * 100;
                const scale = chartH / Math.max(maxReduction * 1.2, 40);
                
                for (let i = 0; i < 7; i++) {
                    const reduction = this.schedule.reductions[i] * 100;
                    const barHeight = reduction * scale;
                    const x = padding.left + (i + 0.5) * (chartW / 7) - barWidth / 2;
                    const y = h - padding.bottom - barHeight;
                    
                    // Bar gradient
                    const gradient = ctx.createLinearGradient(x, y, x, h - padding.bottom);
                    gradient.addColorStop(0, '#58a6ff');
                    gradient.addColorStop(1, '#39c5cf');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // Reduction value on top of bar
                    ctx.fillStyle = '#1f2328';
                    ctx.font = 'bold 11px JetBrains Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(reduction.toFixed(1) + '%', x + barWidth / 2, y - 5);
                    
                    // Stand label
                    ctx.fillStyle = '#57606a';
                    ctx.font = '11px Rajdhani';
                    ctx.fillText(`F${i + 1}`, x + barWidth / 2, h - padding.bottom + 15);
                    
                    // Thickness below bar
                    ctx.fillStyle = '#8b949e';
                    ctx.font = '9px JetBrains Mono';
                    ctx.fillText(this.schedule.thicknesses[i + 1].toFixed(2), x + barWidth / 2, h - padding.bottom + 28);
                }
                
                // Draw entry/exit thickness labels
                ctx.fillStyle = '#39c5cf';
                ctx.font = 'bold 11px JetBrains Mono';
                ctx.textAlign = 'left';
                ctx.fillText('Entry: ' + this.schedule.thicknesses[0].toFixed(1) + 'mm', 5, 15);
                ctx.textAlign = 'right';
                ctx.fillText('Exit: ' + this.schedule.thicknesses[7].toFixed(3) + 'mm', w - 5, 15);
                
                // Y-axis label
                ctx.save();
                ctx.translate(12, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillStyle = '#8b949e';
                ctx.font = '10px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText('Reduction %', 0, 0);
                ctx.restore();
            },
            
            start: function() {
                if (this.isRunning && !this.isPaused) return;
                
                this.isRunning = true;
                this.isPaused = false;
                this.lastFrameTime = performance.now();
                
                this.updateStatus('running');
                this.loop();
            },
            
            pause: function() {
                this.isPaused = true;
                this.updateStatus('paused');
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
            },
            
            stop: function() {
                this.isRunning = false;
                this.isPaused = false;
                this.updateStatus('stopped');
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
            },
            
            reset: function() {
                this.stop();
                this.simTime = 0;
                this.strip.position = 0;
                this.strip.currentThickness = this.strip.entryThickness;
                this.strip.currentTemperature = this.strip.entryTemperature;
                
                // Reset per-stand history
                this.history = {
                    time: [],
                    stands: {
                        thickness: [[], [], [], [], [], [], []],
                        temperature: [[], [], [], [], [], [], []],
                        force: [[], [], [], [], [], [], []],
                        speed: [[], [], [], [], [], [], []],
                        power: [[], [], [], [], [], [], []]
                    },
                    tension: [[], [], [], [], [], []],
                    looperAngle: [[], [], [], [], [], []],
                    zoneTemp: [[], [], [], [], [], [], [], []],
                    maxLength: 300
                };
                
                // Reset ISC integral
                this.iscIntegral = 0;
                
                ControlSystems.reset();
                this.calculateSchedule();
                this.updateDisplay();
            },
            
            loop: function() {
                if (!this.isRunning || this.isPaused) return;
                
                const now = performance.now();
                const elapsed = (now - this.lastFrameTime) / 1000;
                
                // Calculate FPS
                this.frameCount++;
                if (this.frameCount % 30 === 0) {
                    this.fps = Math.round(1 / elapsed);
                    document.getElementById('frameRate').textContent = this.fps + ' fps';
                }
                
                this.lastFrameTime = now;
                
                // Run simulation step
                this.step();
                
                // Update display
                this.updateDisplay();
                
                // Continue loop
                this.animationFrame = requestAnimationFrame(() => this.loop());
            },
            
            step: function() {
                this.simTime += this.dt;
                
                // Add noise for realistic simulation
                const thicknessNoise = (Math.random() - 0.5) * 0.02; // ¬±0.01mm
                const tempNoise = (Math.random() - 0.5) * 4; // ¬±2¬∞C
                
                // Base speed at F7 exit - use optimized speed from schedule
                const baseSpeed = this.schedule.speeds[6] || 8.0; // F7 exit speed from optimization
                const targetFinalH = this.strip.targetExitThickness;
                
                // Process each stand
                let prevH = this.strip.entryThickness + thicknessNoise;
                let prevT = this.strip.entryTemperature + tempNoise;
                let prevV = this.schedule.speeds[0] || 3.5;
                
                for (let i = 0; i < MillConfig.numStands; i++) {
                    const stand = MillConfig.stands[i];
                    const targetH = this.schedule.thicknesses[i + 1];
                    
                    // AGC corrections
                    const ffAdj = ControlSystems.feedforwardAGC(i, prevH - stand.entryH, stand.millModulus);
                    const monAdj = ControlSystems.monitorAGC(i, targetH, stand.exitH, this.dt);
                    
                    // Apply corrections to roll gap
                    const minRollGap = Math.max(0.1, targetH * 0.1);
                    stand.rollGap = targetH + ffAdj + monAdj;
                    stand.rollGap = Math.max(minRollGap, stand.rollGap);
                    
                    // Calculate actual exit thickness
                    const actualH = targetH + (Math.random() - 0.5) * 0.01;
                    
                    // Update speed based on mass flow conservation
                    // V * H = constant, so V = baseSpeed * targetFinalH / H
                    stand.speed = baseSpeed * (targetFinalH / actualH);
                    
                    // Roll speed (considering forward slip)
                    const forwardSlip = 0.03 + 0.02 * (1 - i / MillConfig.numStands);
                    stand.rollSpeed = stand.speed / (1 + forwardSlip);
                    
                    // Calculate rolling force
                    const forceResult = PhysicsModels.calculateRollingForce(
                        stand, this.strip.material, prevH, actualH, 
                        this.strip.width, prevT, stand.speed
                    );
                    
                    stand.force = forceResult.force;
                    stand.contactLength = forceResult.contactLength;
                    
                    // Update stand values
                    stand.entryH = prevH;
                    stand.exitH = actualH;
                    stand.entryT = prevT;
                    stand.reduction = (prevH - stand.exitH) / prevH;
                    
                    // Temperature
                    const tempChange = PhysicsModels.calculateTemperatureChange(
                        this.strip.material, prevH, stand.exitH, prevT, 
                        stand.force, this.strip.width, forceResult.contactLength, stand.speed
                    );
                    stand.exitT = prevT + tempChange.netChange;
                    
                    // Torque and power
                    stand.torque = PhysicsModels.calculateTorque(
                        stand.force, forceResult.contactLength, stand.workRollDia
                    );
                    stand.power = PhysicsModels.calculatePower(
                        stand.torque, stand.speed, stand.workRollDia
                    );
                    
                    // Crown control - adjust bending force and CVC to control strip crown
                    // Target crown varies by stand - downstream stands want flatter strip
                    const targetCrowns = [30, 28, 25, 22, 20, 18, 15]; // Œºm, F1 to F7
                    const targetCrownMicrons = targetCrowns[i];
                    
                    // Thermal crown builds up during rolling (roll heating)
                    // Initialize thermal crown tracking if not present
                    if (stand.thermalCrown === undefined) stand.thermalCrown = 0;
                    // Thermal crown increases with rolling, decays when idle
                    const heatInput = stand.force * stand.speed * 0.0001; // Heat from rolling
                    stand.thermalCrown += heatInput - stand.thermalCrown * 0.02; // Build up and decay
                    stand.thermalCrown = Math.max(0, Math.min(15, stand.thermalCrown)); // Limit 0-15 Œºm
                    
                    const measuredCrown = PhysicsModels.calculateCrown(
                        stand, stand.force, this.strip.width, stand.bendingForce, stand.cvcShift, 
                        stand.thermalCrown, i
                    );
                    
                    // Crown control when enabled
                    const crownCtrlEl = document.getElementById('crownCtrl');
                    if (crownCtrlEl && crownCtrlEl.checked) {
                        const crownErr = measuredCrown - targetCrownMicrons; // Œºm
                        
                        // PI control for bending force (primary actuator)
                        // Negative crown error (too small) -> increase bending force
                        // Positive crown error (too large) -> decrease bending force
                        const Kp_bend = 15; // kN per Œºm error
                        const Ki_bend = 2;  // Integral gain
                        
                        // Initialize integral if needed
                        if (stand.crownIntegral === undefined) stand.crownIntegral = 0;
                        stand.crownIntegral += crownErr * this.dt;
                        stand.crownIntegral = Math.max(-50, Math.min(50, stand.crownIntegral)); // Anti-windup
                        
                        const bendingAdj = -(crownErr * Kp_bend + stand.crownIntegral * Ki_bend) * 0.1;
                        stand.bendingForce += bendingAdj;
                        stand.bendingForce = Math.max(-stand.maxBendingForce, 
                            Math.min(stand.maxBendingForce, stand.bendingForce));
                        
                        // CVC shift control (secondary actuator, for profile optimization)
                        // CVC works alongside bending to achieve target crown
                        // Positive CVC shift -> positive crown contribution
                        // Negative CVC shift -> negative crown contribution
                        
                        const bendingUtilization = Math.abs(stand.bendingForce) / stand.maxBendingForce;
                        
                        // CVC control gain - increases when bending is heavily utilized
                        // When bending is at limit, CVC must do more work
                        const Kp_cvc = 0.5 * (1 + bendingUtilization * 2); // 0.5 to 1.5 mm per Œºm
                        
                        // Crown correction: if crown too low (negative error), increase CVC
                        // Sign: crownErr = measured - target
                        // If measured < target: crownErr negative -> need positive CVC adjustment
                        const cvcAdj = -crownErr * Kp_cvc * 0.02;
                        
                        stand.cvcShift += cvcAdj;
                        stand.cvcShift = Math.max(-stand.maxCVCShift, 
                            Math.min(stand.maxCVCShift, stand.cvcShift));
                    }
                    
                    // Store shape parameters
                    stand.crown = measuredCrown / 1000; // Store in mm for display
                    
                    // Flatness (I-units) - affected by crown deviation from target
                    const crownDeviation = measuredCrown - targetCrownMicrons; // Œºm
                    stand.flatness = crownDeviation * 0.5 + (Math.random() - 0.5) * 2; // I-units
                    
                    // Wedge (Œºm) - affected by CVC shift and random asymmetry
                    stand.wedge = (Math.random() - 0.5) * 10 + (stand.cvcShift || 0) * 0.2;
                    
                    // Mass flow AGC
                    if (i > 0) {
                        const mfAdj = ControlSystems.massFlowAGC(i, prevH, prevV, stand.exitH, stand.speed);
                        stand.speedSetpoint *= (1 + mfAdj);
                    }
                    
                    // Looper control (between stands)
                    if (i < MillConfig.numStands - 1) {
                        const looper = MillConfig.loopers[i];
                        
                        // In mass flow balanced operation, strip speed through looper is constant
                        // (equal to exit speed of upstream stand = entry speed of downstream stand)
                        // Small speed variations from control actions create minor angle fluctuations
                        const stripSpeedAtLooper = stand.speed;
                        const speedVariation = 1 + (Math.random() - 0.5) * 0.01; // ¬±0.5% variation
                        
                        const looperResult = PhysicsModels.calculateLooperDynamics(
                            looper, stripSpeedAtLooper, stripSpeedAtLooper * speedVariation,
                            looper.tension, stand.exitH, this.strip.width
                        );
                        
                        looper.angle = looperResult.angle;
                        looper.loopHeight = looperResult.loopHeight;
                        
                        // Update tension with some dynamics
                        const tensionError = looper.tensionSetpoint - looper.tension;
                        looper.tension += tensionError * 0.1 + (Math.random() - 0.5) * 0.5;
                        looper.tension = Math.max(5, Math.min(50, looper.tension));
                        
                        // Set front tension of current stand = looper tension
                        stand.frontTension = looper.tension;
                        // Set back tension of next stand = looper tension
                        MillConfig.stands[i + 1].backTension = looper.tension;
                        
                        // Control
                        const looperControl = ControlSystems.looperControl(
                            i, looper.angle, looper.angleSetpoint,
                            looper.tension, looper.tensionSetpoint, this.dt
                        );
                        
                        MillConfig.stands[i + 1].speedSetpoint *= (1 + looperControl.speedAdj);
                        
                        // Inter-stand cooling (radiation/convection)
                        const interstandLoss = PhysicsModels.calculateInterstandTempLoss(
                            this.strip.material, stand.exitH, stand.exitT, 5000, stand.speed
                        );
                        stand.exitT += interstandLoss;
                        
                        // Apply inter-stand spray cooling
                        const spray = CoolingSystem.sprays[i];
                        CoolingSystem.updateActuator(i, this.dt);
                        
                        const coolingResult = CoolingSystem.calculateCooling(
                            i, stand.exitT, stand.exitH, this.strip.width, 
                            stand.speed, this.strip.material
                        );
                        
                        spray.tempDrop = coolingResult.tempDrop;
                        spray.heatRemoved = coolingResult.heatRemoved;
                        spray.waterFlow = coolingResult.waterFlow;
                        
                        stand.exitT -= coolingResult.tempDrop;
                    }
                    
                    prevH = stand.exitH;
                    prevT = stand.exitT;
                    prevV = stand.speed;
                }
                
                // ============================================================
                // CASCADED FDT CONTROL SYSTEM
                // Primary: ISC spray control (fast, no productivity impact)
                // Secondary: Speed control (slow, only when ISC saturates)
                // ============================================================
                
                const mat = MaterialDatabase.grades[this.strip.material];
                const targetFDT = mat ? (mat.targetFDT.min + mat.targetFDT.max) / 2 : 880;
                const actualFDT = MillConfig.stands[6].exitT;
                const fdtError = actualFDT - targetFDT; // Positive = too hot
                
                // Initialize cascade control state
                if (this.cascadeState === undefined) {
                    this.cascadeState = {
                        iscIntegral: 0,
                        iscFilteredError: 0,
                        iscBaseFlow: 50,
                        speedIntegral: 0,
                        speedFilteredError: 0,
                        speedMultiplier: 1.0,
                        iscSaturated: false
                    };
                }
                
                let speedMult = 1.0;
                const iscAutoEnabled = document.getElementById('iscAuto').checked;
                const tempCtrlEnabled = document.getElementById('tempCtrl').checked;
                
                if (iscAutoEnabled) {
                    // ========== PRIMARY: ISC SPRAY CONTROL ==========
                    // Fast response, fine adjustment, no productivity impact
                    
                    const filterAlpha = 0.15; // Moderate filtering
                    this.cascadeState.iscFilteredError = filterAlpha * fdtError + 
                        (1 - filterAlpha) * this.cascadeState.iscFilteredError;
                    
                    // ISC controller gains - adaptive based on error magnitude
                    const absError = Math.abs(this.cascadeState.iscFilteredError);
                    const Kp_isc = absError > 50 ? 1.5 : (absError > 20 ? 1.0 : 0.8);
                    const Ki_isc = absError > 50 ? 0.03 : 0.015;
                    
                    // Accumulate integral with higher limits for large errors
                    if (Math.abs(this.cascadeState.iscFilteredError) > 1.5) {
                        this.cascadeState.iscIntegral += this.cascadeState.iscFilteredError * this.dt;
                        const integralLimit = absError > 50 ? 100 : 50;
                        this.cascadeState.iscIntegral = Math.max(-integralLimit, Math.min(integralLimit, this.cascadeState.iscIntegral));
                    } else {
                        this.cascadeState.iscIntegral *= 0.99;
                    }
                    
                    // Calculate ISC control output
                    const iscOutput = Kp_isc * this.cascadeState.iscFilteredError + 
                                      Ki_isc * this.cascadeState.iscIntegral;
                    
                    // Target flow (centered at 50%)
                    let targetFlow = 50 + iscOutput;
                    
                    // Faster adjustment for large errors
                    const adjRate = absError > 30 ? 0.15 : 0.08;
                    this.cascadeState.iscBaseFlow += (targetFlow - this.cascadeState.iscBaseFlow) * adjRate;
                    
                    // Clamp to limits
                    this.cascadeState.iscBaseFlow = Math.max(0, Math.min(100, this.cascadeState.iscBaseFlow));
                    
                    // Check for saturation - ISC can't achieve target alone
                    // Works for BOTH directions: too hot (need more cooling) AND too cold (need less cooling)
                    const ISC_MIN = 5;
                    const ISC_MAX = 95;
                    const atFlowLimit = this.cascadeState.iscBaseFlow <= ISC_MIN || 
                                        this.cascadeState.iscBaseFlow >= ISC_MAX;
                    
                    // Too HOT: high flow but still can't cool enough
                    const tooHotStrugging = fdtError > 10 && this.cascadeState.iscBaseFlow > 70;
                    
                    // Too COLD: low flow but still overcooling
                    const tooColdStruggling = fdtError < -10 && this.cascadeState.iscBaseFlow < 30;
                    
                    // Large error in either direction
                    const persistentLargeError = absError > 15;
                    
                    this.cascadeState.iscSaturated = atFlowLimit || tooHotStrugging || tooColdStruggling || persistentLargeError;
                    
                    // Log saturation status periodically
                    if (this.frameCount % 60 === 0 && this.cascadeState.iscSaturated) {
                        const reason = atFlowLimit ? 'flow limit' : 
                                      tooHotStrugging ? 'too hot, ISC maxed' : 
                                      tooColdStruggling ? 'too cold, ISC at min' : 'large error';
                        console.log(`ISC Saturation: flow=${this.cascadeState.iscBaseFlow.toFixed(1)}%, error=${fdtError.toFixed(1)}¬∞C, reason=${reason}`);
                    }
                    
                    // Apply to spray zones
                    const distribution = [1.05, 1.02, 1.0, 0.98, 0.97, 0.95];
                    for (let z = 0; z < 6; z++) {
                        const zoneSpray = CoolingSystem.sprays[z];
                        let newFlow = this.cascadeState.iscBaseFlow * distribution[z];
                        newFlow = Math.max(0, Math.min(100, newFlow));
                        
                        zoneSpray.flowSetpoint += (newFlow - zoneSpray.flowSetpoint) * 0.1;
                        zoneSpray.actualFlow = zoneSpray.flowSetpoint;
                        
                        // Update UI
                        if (this.frameCount % 5 === 0) {
                            const slider = document.getElementById(`spraySlider${z}`);
                            const valueEl = document.getElementById(`sprayValue${z}`);
                            if (slider && valueEl) {
                                slider.value = zoneSpray.flowSetpoint;
                                valueEl.textContent = zoneSpray.flowSetpoint.toFixed(0) + '%';
                            }
                        }
                    }
                    
                    // ========== SECONDARY: SPEED CONTROL (when ISC saturates) ==========
                    // Only activates when ISC hits limits and can't control FDT alone
                    // Too HOT ‚Üí slow down (more cooling time)
                    // Too COLD ‚Üí speed up (less cooling time)
                    
                    if (tempCtrlEnabled && this.cascadeState.iscSaturated) {
                        // Faster filter for speed response
                        const speedFilterAlpha = absError > 30 ? 0.15 : 0.08;
                        this.cascadeState.speedFilteredError = speedFilterAlpha * fdtError + 
                            (1 - speedFilterAlpha) * this.cascadeState.speedFilteredError;
                        
                        // More aggressive speed gains
                        const absSpeedError = Math.abs(this.cascadeState.speedFilteredError);
                        const Kp_speed = 0.005;  // 0.5% speed change per 1¬∞C error
                        const Ki_speed = 0.001;  // Integral for steady-state elimination
                        
                        // Accumulate integral
                        if (absSpeedError > 3) {
                            this.cascadeState.speedIntegral += this.cascadeState.speedFilteredError * this.dt;
                            this.cascadeState.speedIntegral = Math.max(-40, Math.min(40, this.cascadeState.speedIntegral));
                        } else {
                            this.cascadeState.speedIntegral *= 0.98;
                        }
                        
                        // Speed adjustment:
                        // Positive error (too hot) ‚Üí negative adj ‚Üí slow down
                        // Negative error (too cold) ‚Üí positive adj ‚Üí speed up
                        const speedAdj = -(Kp_speed * this.cascadeState.speedFilteredError + 
                                          Ki_speed * this.cascadeState.speedIntegral);
                        
                        // Target speed multiplier
                        const targetSpeedMult = 1.0 + speedAdj;
                        
                        // Faster speed change rate
                        const speedChangeRate = 0.08;
                        this.cascadeState.speedMultiplier += 
                            (targetSpeedMult - this.cascadeState.speedMultiplier) * speedChangeRate;
                        
                        // Speed range: ¬±30%
                        this.cascadeState.speedMultiplier = 
                            Math.max(0.70, Math.min(1.30, this.cascadeState.speedMultiplier));
                        
                        speedMult = this.cascadeState.speedMultiplier;
                        
                        // Log speed control action periodically
                        if (this.frameCount % 60 === 0) {
                            console.log(`Speed Control: error=${fdtError.toFixed(1)}¬∞C, speedMult=${(speedMult*100).toFixed(1)}%, adj=${(speedAdj*100).toFixed(2)}%`);
                        }
                        
                    } else if (!this.cascadeState.iscSaturated) {
                        // ISC not saturated - slowly return speed to nominal
                        this.cascadeState.speedMultiplier += (1.0 - this.cascadeState.speedMultiplier) * 0.02;
                        this.cascadeState.speedIntegral *= 0.98;
                        speedMult = this.cascadeState.speedMultiplier;
                    }
                    
                } else if (tempCtrlEnabled) {
                    // ISC Auto OFF, Temp Ctrl ON - use speed control only
                    speedMult = ControlSystems.temperatureControl(targetFDT, actualFDT, this.dt);
                }
                // else: Both OFF - pure manual mode, speedMult stays 1.0
                
                // Apply speed multiplier with dynamic variations
                for (let i = 0; i < MillConfig.numStands; i++) {
                    const stand = MillConfig.stands[i];
                    // Base speed from schedule with temperature control adjustment
                    const baseSpeed = this.schedule.speeds[i] * speedMult;
                    // Add small random variation (¬±1%) to make display dynamic
                    const variation = 1 + (Math.random() - 0.5) * 0.02;
                    stand.speed = baseSpeed * variation;
                    // Update roll speed (considering forward slip)
                    const forwardSlip = 0.03 + 0.02 * (1 - i / MillConfig.numStands);
                    stand.rollSpeed = stand.speed / (1 + forwardSlip);
                }
                
                // Set F1 back tension (from rougher mill or crop shear - typically low)
                MillConfig.stands[0].backTension = 5 + (Math.random() - 0.5) * 1;
                
                // Set F7 front tension (to coiler - typically 15-25 MPa for electrical steel)
                MillConfig.stands[6].frontTension = 20 + (Math.random() - 0.5) * 2;
                
                // Update strip state
                this.strip.currentThickness = MillConfig.stands[6].exitH;
                this.strip.currentTemperature = MillConfig.stands[6].exitT;
                this.strip.position += MillConfig.stands[6].speed * this.dt;
                
                // Store history
                this.addToHistory();
            },
            
            addToHistory: function() {
                this.history.time.push(this.simTime);
                
                // Store per-stand data
                for (let i = 0; i < 7; i++) {
                    const stand = MillConfig.stands[i];
                    this.history.stands.thickness[i].push(stand.exitH);
                    this.history.stands.temperature[i].push(stand.exitT);
                    this.history.stands.force[i].push(stand.force);
                    this.history.stands.speed[i].push(stand.speed);
                    this.history.stands.power[i].push(stand.power);
                }
                
                // Store looper tensions and angles
                for (let i = 0; i < 6; i++) {
                    this.history.tension[i].push(MillConfig.loopers[i]?.tension || 15);
                    this.history.looperAngle[i].push(MillConfig.loopers[i]?.angle || 25);
                }
                
                // Store zone temperatures (entry + 7 stand exits)
                this.history.zoneTemp[0].push(this.strip.entryTemperature);
                for (let i = 0; i < 7; i++) {
                    this.history.zoneTemp[i + 1].push(MillConfig.stands[i].exitT);
                }
                
                // Limit history length
                if (this.history.time.length > this.history.maxLength) {
                    this.history.time.shift();
                    for (let i = 0; i < 7; i++) {
                        this.history.stands.thickness[i].shift();
                        this.history.stands.temperature[i].shift();
                        this.history.stands.force[i].shift();
                        this.history.stands.speed[i].shift();
                        this.history.stands.power[i].shift();
                    }
                    for (let i = 0; i < 6; i++) {
                        this.history.tension[i].shift();
                        this.history.looperAngle[i].shift();
                    }
                    for (let i = 0; i < 8; i++) {
                        this.history.zoneTemp[i].shift();
                    }
                }
            },
            
            // Predict FDT from current position
            predictFDT: function(currentStandIndex, currentTemp) {
                let predictedTemp = currentTemp;
                
                for (let i = currentStandIndex + 1; i < MillConfig.numStands; i++) {
                    const stand = MillConfig.stands[i];
                    const prevStand = MillConfig.stands[i - 1];
                    
                    // Estimate deformation heating
                    const strain = Math.log(prevStand.exitH / stand.exitH);
                    predictedTemp += strain * 12; // Approximate heating
                    
                    // Estimate inter-stand cooling (radiation + spray)
                    if (i < MillConfig.numStands - 1) {
                        predictedTemp -= 8 + CoolingSystem.sprays[i].flowSetpoint * 0.15;
                    }
                }
                
                return predictedTemp;
            },
            
            updateStatus: function(status) {
                const indicator = document.getElementById('statusIndicator');
                const text = document.getElementById('statusText');
                const btnStart = document.getElementById('btnStart');
                const btnPause = document.getElementById('btnPause');
                const btnStop = document.getElementById('btnStop');
                
                indicator.className = 'status-indicator ' + status;
                text.textContent = status.toUpperCase();
                
                if (status === 'running') {
                    btnStart.style.display = 'none';
                    btnPause.style.display = 'inline-block';
                    btnStop.style.display = 'inline-block';
                } else if (status === 'paused') {
                    btnStart.style.display = 'inline-block';
                    btnStart.textContent = '‚ñ∂ Resume';
                    btnPause.style.display = 'none';
                    btnStop.style.display = 'inline-block';
                } else {
                    btnStart.style.display = 'inline-block';
                    btnStart.textContent = '‚ñ∂ Start';
                    btnPause.style.display = 'none';
                    btnStop.style.display = 'none';
                }
            },
            
            initUI: function() {
                this.createStandCards();
                this.createLooperDisplay();
                this.createCoolingZones();
                this.initCanvas();
                this.initTrendChart();
                this.updateDisplay();
            },
            
            createCoolingZones: function() {
                const container = document.getElementById('coolingZones');
                container.innerHTML = '';
                
                for (let i = 0; i < CoolingSystem.sprays.length; i++) {
                    const spray = CoolingSystem.sprays[i];
                    const zone = document.createElement('div');
                    zone.className = 'cooling-zone';
                    
                    zone.innerHTML = `
                        <div class="cooling-zone-header">
                            <span class="cooling-zone-name">${spray.name}</span>
                            <span class="cooling-zone-stats">
                                <span id="sprayTempDrop${i}">0</span>¬∞C | 
                                <span id="sprayHeat${i}">0</span>kW
                            </span>
                        </div>
                        <div class="cooling-zone-controls">
                            <input type="range" class="cooling-zone-slider" 
                                   id="spraySlider${i}" 
                                   min="0" max="100" step="1" 
                                   value="${spray.flowSetpoint}"
                                   oninput="updateSprayFlow(${i}, this.value)"
                                   onchange="updateSprayFlow(${i}, this.value)">
                            <span class="cooling-zone-value" id="sprayValue${i}">${spray.flowSetpoint}%</span>
                        </div>
                    `;
                    
                    container.appendChild(zone);
                }
            },
            
            createStandCards: function() {
                const container = document.getElementById('standsOverview');
                container.innerHTML = '';
                
                for (let i = 0; i < MillConfig.numStands; i++) {
                    const stand = MillConfig.stands[i];
                    const card = document.createElement('div');
                    card.className = 'stand-card' + (i === 0 ? ' active' : '');
                    card.id = `standCard${i}`;
                    card.onclick = () => this.selectStand(i);
                    
                    const exitH = stand.exitH ? stand.exitH.toFixed(3) : '0.000';
                    const rollGap = stand.rollGap ? stand.rollGap.toFixed(3) : '0.000';
                    const force = stand.force ? stand.force.toFixed(1) : '0.0';
                    const torque = stand.torque ? stand.torque.toFixed(0) : '0';
                    const power = stand.power ? stand.power.toFixed(2) : '0.00';
                    const rollSpeed = stand.rollSpeed ? stand.rollSpeed.toFixed(2) : '0.00';
                    const stripSpeed = stand.speed ? stand.speed.toFixed(2) : '0.00';
                    const backTension = stand.backTension ? stand.backTension.toFixed(1) : '0.0';
                    const frontTension = stand.frontTension ? stand.frontTension.toFixed(1) : '0.0';
                    
                    card.innerHTML = `
                        <div class="stand-header">
                            <span class="stand-name">${stand.name}</span>
                        </div>
                        <div class="stand-data-grid">
                            <div class="stand-data-row">
                                <span class="stand-data-label">Exit H:</span>
                                <span class="stand-data-value" id="standExitH${i}">${exitH}</span>
                                <span class="stand-data-unit">mm</span>
                            </div>
                            <div class="stand-data-row">
                                <span class="stand-data-label">Roll Gap:</span>
                                <span class="stand-data-value" id="standGap${i}">${rollGap}</span>
                                <span class="stand-data-unit">mm</span>
                            </div>
                            <div class="stand-data-row">
                                <span class="stand-data-label">Force:</span>
                                <span class="stand-data-value" id="standForceCard${i}">${force}</span>
                                <span class="stand-data-unit">MN</span>
                            </div>
                            <div class="stand-data-row">
                                <span class="stand-data-label">Torque:</span>
                                <span class="stand-data-value" id="standTorqueCard${i}">${torque}</span>
                                <span class="stand-data-unit">kNm</span>
                            </div>
                            <div class="stand-data-row">
                                <span class="stand-data-label">Power:</span>
                                <span class="stand-data-value" id="standPowerCard${i}">${power}</span>
                                <span class="stand-data-unit">MW</span>
                            </div>
                            <div class="stand-data-row">
                                <span class="stand-data-label">Roll Spd:</span>
                                <span class="stand-data-value" id="standRollSpeed${i}">${rollSpeed}</span>
                                <span class="stand-data-unit">m/s</span>
                            </div>
                            <div class="stand-data-row">
                                <span class="stand-data-label">Strip Spd:</span>
                                <span class="stand-data-value" id="standStripSpeed${i}">${stripSpeed}</span>
                                <span class="stand-data-unit">m/s</span>
                            </div>
                            <div class="stand-data-row">
                                <span class="stand-data-label">Back œÉ:</span>
                                <span class="stand-data-value" id="standBackTension${i}">${backTension}</span>
                                <span class="stand-data-unit">MPa</span>
                            </div>
                            <div class="stand-data-row">
                                <span class="stand-data-label">Front œÉ:</span>
                                <span class="stand-data-value" id="standFrontTension${i}">${frontTension}</span>
                                <span class="stand-data-unit">MPa</span>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(card);
                }
            },
            
            createLooperDisplay: function() {
                const container = document.getElementById('looperDisplay');
                container.innerHTML = '';
                
                for (let i = 0; i < MillConfig.loopers.length; i++) {
                    const looper = MillConfig.loopers[i];
                    const item = document.createElement('div');
                    item.className = 'looper-item';
                    
                    item.innerHTML = `
                        <div class="looper-visual">
                            <div class="looper-arm" id="looperArm${i}" style="transform: translateX(-50%) rotate(${-looper.angle}deg);"></div>
                        </div>
                        <div class="looper-value" id="looperAngle${i}">${looper.angle.toFixed(1)}¬∞</div>
                        <div class="looper-tension" id="looperTension${i}">${looper.tension.toFixed(1)} MPa</div>
                        <div class="stand-label">${looper.name}</div>
                    `;
                    
                    container.appendChild(item);
                }
            },
            
            selectedStand: 0,
            
            selectStand: function(index) {
                // Update active card
                document.querySelectorAll('.stand-card').forEach((card, i) => {
                    card.classList.toggle('active', i === index);
                });
                
                this.selectedStand = index;
                
                // Update status tables to reflect current selection
                this.updateStandsStatusTable();
            },
            
            updateDisplay: function() {
                // Update sim time
                const minutes = Math.floor(this.simTime / 60);
                const seconds = (this.simTime % 60).toFixed(3);
                document.getElementById('simTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.padStart(6, '0')}`;
                
                // Update strip info
                document.getElementById('stripLength').textContent = this.strip.position.toFixed(1) + ' m';
                const progress = Math.min(100, (this.strip.position / this.strip.length) * 100);
                document.getElementById('coilProgress').textContent = progress.toFixed(0) + '%';
                
                // Update current values (status cards in overview)
                document.getElementById('currentThickness').textContent = this.strip.currentThickness.toFixed(2);
                document.getElementById('currentTemp').textContent = this.strip.currentTemperature.toFixed(0);
                document.getElementById('stripPosition').textContent = this.strip.position.toFixed(1);
                document.getElementById('currentSpeed').textContent = 
                    (MillConfig.stands[6]?.speed || 0).toFixed(1);
                
                // Update target displays
                document.getElementById('targetThicknessDisplay').textContent = this.strip.targetExitThickness.toFixed(2);
                const mat = MaterialDatabase.grades[this.strip.material];
                const targetFDT = mat ? (mat.targetFDT.min + mat.targetFDT.max) / 2 : 880;
                document.getElementById('targetFDTDisplay').textContent = targetFDT.toFixed(0);
                
                // Thickness deviation
                const thickDev = this.strip.currentThickness - this.strip.targetExitThickness;
                const thickDevEl = document.getElementById('thicknessDev');
                thickDevEl.textContent = (thickDev >= 0 ? '+' : '') + thickDev.toFixed(3);
                thickDevEl.className = 'status-card-value ' + (Math.abs(thickDev) > 0.03 ? 'danger' : 
                    Math.abs(thickDev) > 0.015 ? 'warning' : 'success');
                
                // Update crown
                const stand = MillConfig.stands[this.selectedStand];
                const crown = PhysicsModels.calculateCrown(
                    stand, stand.force, this.strip.width, stand.bendingForce, stand.cvcShift, 0
                );
                document.getElementById('currentCrown').textContent = crown.toFixed(0);
                
                // Update stand cards with all values
                for (let i = 0; i < MillConfig.numStands; i++) {
                    const s = MillConfig.stands[i];
                    
                    const exitHEl = document.getElementById(`standExitH${i}`);
                    if (exitHEl) exitHEl.textContent = s.exitH.toFixed(3);
                    
                    const gapEl = document.getElementById(`standGap${i}`);
                    if (gapEl) gapEl.textContent = s.rollGap.toFixed(3);
                    
                    const forceEl = document.getElementById(`standForceCard${i}`);
                    if (forceEl) forceEl.textContent = s.force.toFixed(1);
                    
                    const torqueEl = document.getElementById(`standTorqueCard${i}`);
                    if (torqueEl) torqueEl.textContent = (s.torque || 0).toFixed(0);
                    
                    const powerEl = document.getElementById(`standPowerCard${i}`);
                    if (powerEl) powerEl.textContent = (s.power || 0).toFixed(2);
                    
                    const rollSpeedEl = document.getElementById(`standRollSpeed${i}`);
                    if (rollSpeedEl) rollSpeedEl.textContent = (s.rollSpeed || 0).toFixed(2);
                    
                    const stripSpeedEl = document.getElementById(`standStripSpeed${i}`);
                    if (stripSpeedEl) stripSpeedEl.textContent = (s.speed || 0).toFixed(2);
                    
                    const backTensionEl = document.getElementById(`standBackTension${i}`);
                    if (backTensionEl) backTensionEl.textContent = (s.backTension || 0).toFixed(1);
                    
                    const frontTensionEl = document.getElementById(`standFrontTension${i}`);
                    if (frontTensionEl) frontTensionEl.textContent = (s.frontTension || 0).toFixed(1);
                }
                
                // Update looper display
                for (let i = 0; i < MillConfig.loopers.length; i++) {
                    const looper = MillConfig.loopers[i];
                    const armEl = document.getElementById(`looperArm${i}`);
                    const angleEl = document.getElementById(`looperAngle${i}`);
                    const tensionEl = document.getElementById(`looperTension${i}`);
                    if (armEl) armEl.style.transform = `translateX(-50%) rotate(${-looper.angle}deg)`;
                    if (angleEl) angleEl.textContent = looper.angle.toFixed(1) + '¬∞';
                    if (tensionEl) tensionEl.textContent = looper.tension.toFixed(1) + ' MPa';
                }
                
                // Update all stands status table in Control tab
                this.updateStandsStatusTable();
                
                // Update cooling display
                let totalWaterFlow = 0;
                let totalHeatRemoved = 0;
                for (let i = 0; i < CoolingSystem.sprays.length; i++) {
                    const spray = CoolingSystem.sprays[i];
                    totalWaterFlow += spray.waterFlow;
                    totalHeatRemoved += spray.heatRemoved;
                    
                    // Update slider and value display
                    const slider = document.getElementById(`spraySlider${i}`);
                    const valueEl = document.getElementById(`sprayValue${i}`);
                    const tempDropEl = document.getElementById(`sprayTempDrop${i}`);
                    const heatEl = document.getElementById(`sprayHeat${i}`);
                    
                    if (slider && valueEl) {
                        slider.value = spray.flowSetpoint;
                        valueEl.textContent = spray.actualFlow.toFixed(0) + '%';
                    }
                    if (tempDropEl) tempDropEl.textContent = spray.tempDrop.toFixed(1);
                    if (heatEl) heatEl.textContent = spray.heatRemoved.toFixed(0);
                }
                document.getElementById('totalWaterFlow').textContent = totalWaterFlow.toFixed(0) + ' L/min';
                document.getElementById('totalHeatRemoved').textContent = (totalHeatRemoved / 1000).toFixed(2) + ' MW';
                
                // Update FDT display (reuse mat and targetFDT from above)
                const actualFDT = MillConfig.stands[6]?.exitT || this.strip.currentTemperature;
                const fdtError = actualFDT - targetFDT;
                
                const targetFDTEl = document.getElementById('targetFDTCooling');
                if (targetFDTEl) targetFDTEl.textContent = targetFDT.toFixed(0) + '¬∞C';
                
                const actualFDTEl = document.getElementById('actualFDT');
                if (actualFDTEl) {
                    actualFDTEl.textContent = actualFDT.toFixed(0) + '¬∞C';
                    actualFDTEl.style.color = Math.abs(fdtError) > 20 ? 'var(--accent-red)' : 
                                              Math.abs(fdtError) > 10 ? 'var(--accent-yellow)' : 'var(--accent-green)';
                }
                
                const fdtErrorEl = document.getElementById('fdtError');
                if (fdtErrorEl) {
                    fdtErrorEl.textContent = (fdtError >= 0 ? '+' : '') + fdtError.toFixed(1) + '¬∞C';
                    fdtErrorEl.style.color = Math.abs(fdtError) > 20 ? 'var(--accent-red)' : 
                                             Math.abs(fdtError) > 10 ? 'var(--accent-yellow)' : 'var(--accent-green)';
                }
                
                // Update cascade control status display
                const controlModeEl = document.getElementById('controlModeDisplay');
                const speedMultEl = document.getElementById('speedMultDisplay');
                
                if (controlModeEl) {
                    const iscAuto = document.getElementById('iscAuto')?.checked;
                    const tempCtrl = document.getElementById('tempCtrl')?.checked;
                    
                    let modeText = 'Manual';
                    let modeColor = 'var(--text-secondary)';
                    
                    if (iscAuto) {
                        if (this.cascadeState?.iscSaturated && tempCtrl) {
                            modeText = 'ISC Saturated ‚Üí Speed Assist';
                            modeColor = 'var(--accent-yellow)';
                        } else if (this.cascadeState?.iscSaturated) {
                            modeText = 'ISC Saturated (Speed OFF)';
                            modeColor = 'var(--accent-red)';
                        } else {
                            modeText = 'ISC Auto (Primary)';
                            modeColor = 'var(--accent-green)';
                        }
                    } else if (tempCtrl) {
                        modeText = 'Speed Control Only';
                        modeColor = 'var(--accent-blue)';
                    }
                    
                    controlModeEl.textContent = modeText;
                    controlModeEl.style.color = modeColor;
                }
                
                if (speedMultEl) {
                    const mult = this.cascadeState?.speedMultiplier || 1.0;
                    const pct = (mult * 100).toFixed(1);
                    speedMultEl.textContent = pct + '%';
                    speedMultEl.style.color = Math.abs(mult - 1.0) > 0.05 ? 'var(--accent-yellow)' : 'var(--text-primary)';
                }
                
                // Update canvas (only if overview tab is active)
                if (document.getElementById('tab-overview').classList.contains('active')) {
                    this.drawCanvas();
                }
                
                // Update trend chart (only if trends tab is active)
                if (document.getElementById('tab-trends').classList.contains('active')) {
                    this.drawTrendChart();
                }
                
                // Update looper trends (only if control tab is active)
                if (document.getElementById('tab-control').classList.contains('active')) {
                    this.drawLooperTrends();
                }
                
                // Update zone temperature trends (only if cooling tab is active)
                if (document.getElementById('tab-cooling').classList.contains('active')) {
                    this.drawZoneTempTrends();
                }
            },
            
            canvas: null,
            ctx: null,
            currentView: 'schematic',
            
            initCanvas: function() {
                this.canvas = document.getElementById('millCanvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            },
            
            resizeCanvas: function() {
                if (!this.canvas) return;
                const container = this.canvas.parentElement;
                if (!container) return;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.drawCanvas();
            },
            
            drawCanvas: function() {
                if (!this.ctx || !this.canvas) return;
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // Clear
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                if (this.currentView === 'schematic') {
                    this.drawSchematic(ctx, w, h);
                } else if (this.currentView === 'profile') {
                    this.drawProfile(ctx, w, h);
                } else if (this.currentView === 'temperature') {
                    this.drawTemperature(ctx, w, h);
                }
            },
            
            drawSchematic: function(ctx, w, h) {
                const standSpacing = (w - 120) / 8;
                const centerY = h / 2;
                const stripHalfThickness = 4; // Visual half-thickness of strip
                
                // Draw stands
                for (let i = 0; i < MillConfig.numStands; i++) {
                    const stand = MillConfig.stands[i];
                    const x = 60 + (i + 1) * standSpacing;
                    
                    // Roll sizes (work rolls smaller toward F7, backup rolls larger)
                    const workRollRadius = 18 - i * 1.5; // F1=18, F7=9
                    const backupRollRadius = 32 - i * 2;  // F1=32, F7=20 (always larger than work)
                    
                    // Calculate roll positions - work rolls touch the strip
                    const workRollY = stripHalfThickness + workRollRadius; // Work roll center
                    const backupRollY = workRollY + workRollRadius + backupRollRadius + 2; // Backup touches work
                    
                    // Housing (stand frame) - darker background
                    ctx.fillStyle = '#6e7781';
                    ctx.strokeStyle = '#3a4a5c';
                    ctx.lineWidth = 2;
                    const housingWidth = Math.max(backupRollRadius * 2 + 16, 70);
                    const housingHeight = backupRollY + backupRollRadius + 15;
                    ctx.fillRect(x - housingWidth/2, centerY - housingHeight, housingWidth, housingHeight * 2);
                    ctx.strokeRect(x - housingWidth/2, centerY - housingHeight, housingWidth, housingHeight * 2);
                    
                    // Backup rolls (larger, outer) - metallic gray with gradient
                    const backupGradTop = ctx.createRadialGradient(x - 5, centerY - backupRollY - 5, 0, x, centerY - backupRollY, backupRollRadius);
                    backupGradTop.addColorStop(0, '#8090a0');
                    backupGradTop.addColorStop(0.5, '#5a6a7a');
                    backupGradTop.addColorStop(1, '#3a4a5a');
                    ctx.fillStyle = backupGradTop;
                    ctx.beginPath();
                    ctx.arc(x, centerY - backupRollY, backupRollRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#6a7a8a';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    const backupGradBot = ctx.createRadialGradient(x - 5, centerY + backupRollY - 5, 0, x, centerY + backupRollY, backupRollRadius);
                    backupGradBot.addColorStop(0, '#8090a0');
                    backupGradBot.addColorStop(0.5, '#5a6a7a');
                    backupGradBot.addColorStop(1, '#3a4a5a');
                    ctx.fillStyle = backupGradBot;
                    ctx.beginPath();
                    ctx.arc(x, centerY + backupRollY, backupRollRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#6a7a8a';
                    ctx.stroke();
                    
                    // Work rolls (smaller, inner) - brighter with polished look
                    const workGradTop = ctx.createRadialGradient(x - 3, centerY - workRollY - 3, 0, x, centerY - workRollY, workRollRadius);
                    workGradTop.addColorStop(0, '#c0d0e0');
                    workGradTop.addColorStop(0.3, '#90a5b8');
                    workGradTop.addColorStop(0.7, '#6080a0');
                    workGradTop.addColorStop(1, '#405570');
                    ctx.fillStyle = workGradTop;
                    ctx.beginPath();
                    ctx.arc(x, centerY - workRollY, workRollRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#a0b5c8';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    const workGradBot = ctx.createRadialGradient(x - 3, centerY + workRollY - 3, 0, x, centerY + workRollY, workRollRadius);
                    workGradBot.addColorStop(0, '#c0d0e0');
                    workGradBot.addColorStop(0.3, '#90a5b8');
                    workGradBot.addColorStop(0.7, '#6080a0');
                    workGradBot.addColorStop(1, '#405570');
                    ctx.fillStyle = workGradBot;
                    ctx.beginPath();
                    ctx.arc(x, centerY + workRollY, workRollRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#a0b5c8';
                    ctx.stroke();
                    
                    // Stand label
                    ctx.fillStyle = '#c0d0e0';
                    ctx.font = 'bold 13px Rajdhani';
                    ctx.textAlign = 'center';
                    ctx.fillText(stand.name, x, centerY + backupRollY + backupRollRadius + 30);
                    
                    // Force indicator bar (above housing)
                    const forceRatio = stand.force / stand.maxForce;
                    const barMaxHeight = 25;
                    const barHeight = forceRatio * barMaxHeight;
                    const barY = centerY - housingHeight - 8;
                    
                    // Force bar background
                    ctx.fillStyle = '#6e7781';
                    ctx.fillRect(x - 8, barY - barMaxHeight, 16, barMaxHeight);
                    ctx.strokeStyle = '#3a4a5c';
                    ctx.strokeRect(x - 8, barY - barMaxHeight, 16, barMaxHeight);
                    
                    // Force bar fill
                    const forceColor = forceRatio > 0.9 ? '#f85149' : forceRatio > 0.75 ? '#d29922' : '#3fb950';
                    ctx.fillStyle = forceColor;
                    ctx.fillRect(x - 6, barY - barHeight, 12, barHeight);
                    
                    // Force value text
                    ctx.fillStyle = '#57606a';
                    ctx.font = '9px JetBrains Mono';
                    ctx.fillText(stand.force.toFixed(1), x, barY - barMaxHeight - 4);
                    
                    // Draw inter-stand cooling sprays
                    if (i < MillConfig.numStands - 1) {
                        const spray = CoolingSystem.sprays[i];
                        const sprayX = x + standSpacing / 2;
                        const sprayIntensity = spray.actualFlow / 100;
                        
                        if (sprayIntensity > 0.05) {
                            // Draw spray headers (nozzle bars)
                            ctx.fillStyle = '#4090b0';
                            ctx.fillRect(sprayX - 18, centerY - 35, 36, 5);
                            ctx.fillRect(sprayX - 18, centerY + 30, 36, 5);
                            
                            // Draw water spray droplets (animated)
                            ctx.strokeStyle = `rgba(80, 180, 220, ${0.4 + sprayIntensity * 0.5})`;
                            ctx.lineWidth = 1.5;
                            
                            const numDrops = Math.floor(sprayIntensity * 6) + 3;
                            const time = this.simTime * 4;
                            
                            for (let d = 0; d < numDrops; d++) {
                                const dropX = sprayX - 14 + (d / (numDrops - 1)) * 28;
                                const dropPhase = ((time + d * 0.25) % 1);
                                const dropLen = 8 + sprayIntensity * 6;
                                
                                // Top spray (downward)
                                ctx.beginPath();
                                ctx.moveTo(dropX, centerY - 30 + dropPhase * 15);
                                ctx.lineTo(dropX, centerY - 30 + dropPhase * 15 + dropLen);
                                ctx.stroke();
                                
                                // Bottom spray (upward)
                                ctx.beginPath();
                                ctx.moveTo(dropX, centerY + 30 - dropPhase * 15);
                                ctx.lineTo(dropX, centerY + 30 - dropPhase * 15 - dropLen);
                                ctx.stroke();
                            }
                            
                            // Flow percentage label
                            ctx.fillStyle = '#50b4dc';
                            ctx.font = '10px JetBrains Mono';
                            ctx.textAlign = 'center';
                            ctx.fillText(spray.actualFlow.toFixed(0) + '%', sprayX, centerY - 42);
                        }
                    }
                }
                
                // Draw strip with temperature gradient
                const stripStartX = 35;
                const stripEndX = w - 35;
                
                // Strip thickness varies along length
                const gradient = ctx.createLinearGradient(stripStartX, 0, stripEndX, 0);
                gradient.addColorStop(0, this.tempToColor(this.strip.entryTemperature));
                for (let i = 0; i < MillConfig.numStands; i++) {
                    gradient.addColorStop((i + 1) / 8, this.tempToColor(MillConfig.stands[i].exitT));
                }
                
                // Draw strip - thickness matches the gap between work rolls (2 * stripHalfThickness = 8)
                ctx.fillStyle = gradient;
                const stripThickness = 8; // Fixed to match roll positioning
                ctx.fillRect(stripStartX, centerY - stripThickness/2, stripEndX - stripStartX, stripThickness);
                
                // Strip edge highlight
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(stripStartX, centerY - stripThickness/2, stripEndX - stripStartX, stripThickness);
                
                // Loopers between stands - looper pushes strip UP from below
                for (let i = 0; i < MillConfig.loopers.length; i++) {
                    const looper = MillConfig.loopers[i];
                    const x1 = 60 + (i + 1) * standSpacing;
                    const x2 = 60 + (i + 2) * standSpacing;
                    const xMid = (x1 + x2) / 2;
                    const loopHeight = 8 + looper.angle * 0.4; // How high the strip is pushed up
                    
                    // Looper arm pivot (below the strip line)
                    ctx.fillStyle = '#6090b0';
                    ctx.beginPath();
                    ctx.arc(xMid, centerY + 50, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Looper arm (pushing up from pivot to roller)
                    const rollerY = centerY - loopHeight - 5; // Roller is ABOVE centerY
                    ctx.strokeStyle = '#6a7a8a';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(xMid, centerY + 50); // From pivot below
                    ctx.lineTo(xMid, rollerY); // To roller above
                    ctx.stroke();
                    
                    // Looper roller (at top of arm, pushing strip up)
                    ctx.fillStyle = '#4080a8';
                    ctx.strokeStyle = '#a0b0c0';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(xMid, rollerY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Strip curve over looper (curves UP)
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = stripThickness * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(x1 + 35, centerY);
                    ctx.quadraticCurveTo(xMid, centerY - loopHeight - 10, x2 - 35, centerY); // Negative = UP
                    ctx.stroke();
                }
                
                // Entry/Exit labels
                ctx.fillStyle = '#57606a';
                ctx.font = '11px Rajdhani';
                ctx.textAlign = 'center';
                ctx.fillText('ENTRY', 35, centerY + 70);
                ctx.fillText((this.strip.entryThickness).toFixed(1) + ' mm', 35, centerY + 82);
                
                ctx.fillText('EXIT', w - 35, centerY + 70);
                ctx.fillText((MillConfig.stands[6]?.exitH || this.strip.targetExitThickness).toFixed(2) + ' mm', w - 35, centerY + 82);
                
                // Progress indicator (strip head position)
                const progressX = stripStartX + (stripEndX - stripStartX) * Math.min(1, this.strip.position / this.strip.length);
                ctx.fillStyle = '#0969da';
                ctx.shadowColor = '#58a6ff';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(progressX, centerY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            },
            
            drawProfile: function(ctx, w, h) {
                const padding = { left: 70, right: 40, top: 40, bottom: 50 };
                const chartW = w - padding.left - padding.right;
                const chartH = h - padding.top - padding.bottom;
                
                // Draw axes
                ctx.strokeStyle = '#d0d7de';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, h - padding.bottom);
                ctx.lineTo(w - padding.right, h - padding.bottom);
                ctx.stroke();
                
                // Y-axis label
                ctx.fillStyle = '#57606a';
                ctx.font = '12px Rajdhani';
                ctx.save();
                ctx.translate(18, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText('Thickness (mm)', 0, 0);
                ctx.restore();
                
                // X-axis label
                ctx.textAlign = 'center';
                ctx.fillText('Stand Position', w / 2, h - 10);
                
                // Calculate max thickness for scaling
                const maxH = this.strip.entryThickness * 1.1;
                const minH = 0;
                
                // Draw Y-axis grid lines and labels
                ctx.font = '10px JetBrains Mono';
                ctx.textAlign = 'right';
                const ySteps = 5;
                for (let i = 0; i <= ySteps; i++) {
                    const val = maxH - (i / ySteps) * maxH;
                    const y = padding.top + (i / ySteps) * chartH;
                    
                    // Grid line
                    ctx.strokeStyle = '#e0e8f0';
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(w - padding.right, y);
                    ctx.stroke();
                    
                    // Label
                    ctx.fillStyle = '#57606a';
                    ctx.fillText(val.toFixed(0), padding.left - 8, y + 4);
                }
                
                // Bar settings
                const numBars = MillConfig.numStands + 1; // Entry + 7 stands
                const barSpacing = chartW / numBars;
                const barWidth = barSpacing * 0.6;
                
                // Color gradient for bars (Entry=dark blue, F7=light blue)
                const barColors = [
                    '#1a5a8a', '#2070a0', '#2888b8', '#38a0d0', 
                    '#50b8e0', '#68c8ec', '#80d8f8', '#98e8ff'
                ];
                
                // Draw bars
                for (let i = 0; i <= MillConfig.numStands; i++) {
                    const thickness = i === 0 ? this.strip.entryThickness : MillConfig.stands[i - 1].exitH;
                    const barHeight = (thickness / maxH) * chartH;
                    const x = padding.left + i * barSpacing + (barSpacing - barWidth) / 2;
                    const y = h - padding.bottom - barHeight;
                    
                    // Bar shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(x + 3, y + 3, barWidth, barHeight);
                    
                    // Bar fill with gradient
                    const gradient = ctx.createLinearGradient(x, y, x + barWidth, y);
                    gradient.addColorStop(0, barColors[i]);
                    gradient.addColorStop(1, barColors[Math.min(i + 1, 7)]);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // Bar border
                    ctx.strokeStyle = '#1a4a6a';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, barWidth, barHeight);
                    
                    // Thickness value on top of bar
                    ctx.fillStyle = '#1f2328';
                    ctx.font = 'bold 11px JetBrains Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(thickness.toFixed(1), x + barWidth / 2, y - 6);
                    
                    // Reduction percentage (except for Entry)
                    if (i > 0) {
                        const prevThickness = i === 1 ? this.strip.entryThickness : MillConfig.stands[i - 2].exitH;
                        const reduction = ((prevThickness - thickness) / prevThickness * 100);
                        ctx.fillStyle = '#d04040';
                        ctx.font = '9px JetBrains Mono';
                        ctx.fillText('-' + reduction.toFixed(0) + '%', x + barWidth / 2, y - 18);
                    }
                    
                    // Stand label below bar
                    ctx.fillStyle = '#57606a';
                    ctx.font = '11px Rajdhani';
                    ctx.fillText(i === 0 ? 'Entry' : `F${i}`, x + barWidth / 2, h - padding.bottom + 18);
                }
            },
            
            drawTemperature: function(ctx, w, h) {
                const padding = 60;
                const chartW = w - 2 * padding;
                const chartH = h - 2 * padding;
                
                // Draw axes
                ctx.strokeStyle = '#d0d7de';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, h - padding);
                ctx.lineTo(w - padding, h - padding);
                ctx.stroke();
                
                // Y-axis label
                ctx.fillStyle = '#57606a';
                ctx.font = '11px Rajdhani';
                ctx.save();
                ctx.translate(20, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText('Temperature (¬∞C)', 0, 0);
                ctx.restore();
                
                // Target FDT band
                const mat = MaterialDatabase.grades[this.strip.material];
                if (mat) {
                    const minTemp = 700;
                    const maxTemp = 1100;
                    const targetMinY = h - padding - ((mat.targetFDT.min - minTemp) / (maxTemp - minTemp)) * chartH;
                    const targetMaxY = h - padding - ((mat.targetFDT.max - minTemp) / (maxTemp - minTemp)) * chartH;
                    
                    ctx.fillStyle = 'rgba(63, 185, 80, 0.1)';
                    ctx.fillRect(padding, targetMaxY, chartW, targetMinY - targetMaxY);
                    
                    ctx.strokeStyle = 'rgba(63, 185, 80, 0.5)';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(padding, targetMinY);
                    ctx.lineTo(w - padding, targetMinY);
                    ctx.moveTo(padding, targetMaxY);
                    ctx.lineTo(w - padding, targetMaxY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw temperature profile
                const minTemp = 700;
                const maxTemp = 1100;
                
                ctx.strokeStyle = '#db6d28';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i <= MillConfig.numStands; i++) {
                    const x = padding + (i / MillConfig.numStands) * chartW;
                    const temp = i === 0 ? this.strip.entryTemperature : MillConfig.stands[i - 1].exitT;
                    const y = h - padding - ((temp - minTemp) / (maxTemp - minTemp)) * chartH;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Points and labels
                for (let i = 0; i <= MillConfig.numStands; i++) {
                    const x = padding + (i / MillConfig.numStands) * chartW;
                    const temp = i === 0 ? this.strip.entryTemperature : MillConfig.stands[i - 1].exitT;
                    const y = h - padding - ((temp - minTemp) / (maxTemp - minTemp)) * chartH;
                    
                    ctx.fillStyle = this.tempToColor(temp);
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#1f2328';
                    ctx.font = '11px JetBrains Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(temp.toFixed(0), x, y - 12);
                    
                    ctx.fillStyle = '#8b949e';
                    ctx.fillText(i === 0 ? 'Entry' : `F${i}`, x, h - padding + 20);
                }
            },
            
            tempToColor: function(temp) {
                // Temperature to color mapping (700-1100¬∞C)
                const t = Math.max(0, Math.min(1, (temp - 700) / 400));
                
                if (t < 0.3) {
                    return `rgb(${180 + t * 250}, ${50 + t * 100}, 50)`;
                } else if (t < 0.6) {
                    return `rgb(255, ${100 + (t - 0.3) * 300}, 50)`;
                } else {
                    return `rgb(255, ${200 + (t - 0.6) * 55}, ${50 + (t - 0.6) * 150})`;
                }
            },
            
            trendCanvases: {},
            trendContexts: {},
            
            // Stand colors for trend lines
            standColors: [
                '#58a6ff', // F1 - Blue
                '#a371f7', // F2 - Purple
                '#f778ba', // F3 - Pink
                '#db6d28', // F4 - Orange
                '#d29922', // F5 - Yellow
                '#3fb950', // F6 - Green
                '#56d4dd'  // F7 - Cyan
            ],
            
            looperColors: [
                '#58a6ff', // L1-2
                '#a371f7', // L2-3
                '#f778ba', // L3-4
                '#db6d28', // L4-5
                '#d29922', // L5-6
                '#3fb950'  // L6-7
            ],
            
            initTrendChart: function() {
                const canvasIds = ['thicknessTrendCanvas', 'tempTrendCanvas', 'forceTrendCanvas', 
                                   'speedTrendCanvas', 'powerTrendCanvas', 'tensionTrendCanvas'];
                
                canvasIds.forEach(id => {
                    const canvas = document.getElementById(id);
                    if (canvas) {
                        const container = canvas.parentElement;
                        canvas.width = container.clientWidth - 16;
                        canvas.height = container.clientHeight - 16;
                        this.trendCanvases[id] = canvas;
                        this.trendContexts[id] = canvas.getContext('2d');
                    }
                });
                
                // Create legends
                this.createLegends();
            },
            
            createLegends: function() {
                // Stand legends (F1-F7)
                const standLegendIds = ['thicknessLegend', 'tempLegend', 'forceLegend', 'speedLegend', 'powerLegend'];
                standLegendIds.forEach(id => {
                    const container = document.getElementById(id);
                    if (container) {
                        container.innerHTML = '';
                        for (let i = 0; i < 7; i++) {
                            const item = document.createElement('span');
                            item.className = 'legend-item';
                            item.innerHTML = `<span class="legend-color" style="background:${this.standColors[i]}"></span>F${i+1}`;
                            container.appendChild(item);
                        }
                    }
                });
                
                // Looper legend (L1-2 to L6-7)
                const tensionLegend = document.getElementById('tensionLegend');
                if (tensionLegend) {
                    tensionLegend.innerHTML = '';
                    for (let i = 0; i < 6; i++) {
                        const item = document.createElement('span');
                        item.className = 'legend-item';
                        item.innerHTML = `<span class="legend-color" style="background:${this.looperColors[i]}"></span>L${i+1}-${i+2}`;
                        tensionLegend.appendChild(item);
                    }
                }
            },
            
            drawTrendChart: function() {
                // Draw all 6 trend charts
                this.drawMultiLineTrend('thicknessTrendCanvas', this.history.stands.thickness, 7, this.standColors, 'mm');
                this.drawMultiLineTrend('tempTrendCanvas', this.history.stands.temperature, 7, this.standColors, '¬∞C');
                this.drawMultiLineTrend('forceTrendCanvas', this.history.stands.force, 7, this.standColors, 'MN');
                this.drawMultiLineTrend('speedTrendCanvas', this.history.stands.speed, 7, this.standColors, 'm/s');
                this.drawMultiLineTrend('powerTrendCanvas', this.history.stands.power, 7, this.standColors, 'MW');
                this.drawMultiLineTrend('tensionTrendCanvas', this.history.tension, 6, this.looperColors, 'MPa');
            },
            
            drawLooperTrends: function() {
                // Draw looper angle trends with setpoint
                this.drawLooperTrendWithSetpoint(
                    'looperAngleTrendCanvas',
                    this.history.looperAngle,
                    25, // Angle setpoint
                    '¬∞',
                    15, 35 // Y-axis range
                );
                
                // Draw looper tension trends with setpoints
                const tensionSetpoints = [10, 12, 14, 16, 18, 20]; // MPa for L1-2 to L6-7
                this.drawLooperTrendWithSetpoints(
                    'looperTensionTrendCanvas',
                    this.history.tension,
                    tensionSetpoints,
                    'MPa',
                    5, 30 // Y-axis range
                );
            },
            
            drawLooperTrendWithSetpoint: function(canvasId, dataArrays, setpoint, unit, minY, maxY) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                // Set canvas size based on container
                const container = canvas.parentElement;
                canvas.width = container.clientWidth - 16;
                canvas.height = 180;
                
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const padding = { left: 30, right: 45, top: 10, bottom: 20 };
                const chartW = w - padding.left - padding.right;
                const chartH = h - padding.top - padding.bottom;
                
                // Clear with lighter background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, w, h);
                
                // Draw grid
                ctx.strokeStyle = '#d0d7de';
                ctx.lineWidth = 1;
                
                // Horizontal grid lines
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (i / 4) * chartH;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(w - padding.right, y);
                    ctx.stroke();
                }
                
                // Y-axis labels
                ctx.fillStyle = '#57606a';
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const val = maxY - (i / 4) * (maxY - minY);
                    const y = padding.top + (i / 4) * chartH;
                    ctx.fillText(val.toFixed(0), padding.left - 4, y + 3);
                }
                
                // Draw setpoint line (dashed)
                const setpointY = padding.top + ((maxY - setpoint) / (maxY - minY)) * chartH;
                ctx.strokeStyle = '#d29922';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(padding.left, setpointY);
                ctx.lineTo(w - padding.right, setpointY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Setpoint label
                ctx.fillStyle = '#d29922';
                ctx.textAlign = 'left';
                ctx.fillText('SP:' + setpoint + unit, w - padding.right + 3, setpointY + 3);
                
                // Draw each looper line
                const looperColors = ['#58a6ff', '#a371f7', '#f778ba', '#db6d28', '#3fb950', '#56d4dd'];
                
                for (let i = 0; i < 6; i++) {
                    const data = dataArrays[i];
                    if (!data || data.length < 2) continue;
                    
                    ctx.strokeStyle = looperColors[i];
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    
                    for (let j = 0; j < data.length; j++) {
                        const x = padding.left + (j / (this.history.maxLength - 1)) * chartW;
                        const y = padding.top + ((maxY - data[j]) / (maxY - minY)) * chartH;
                        
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Current values on right side
                ctx.font = '8px JetBrains Mono';
                for (let i = 0; i < 6; i++) {
                    const data = dataArrays[i];
                    if (data && data.length > 0) {
                        const val = data[data.length - 1];
                        const y = padding.top + ((maxY - val) / (maxY - minY)) * chartH;
                        ctx.fillStyle = looperColors[i];
                        ctx.textAlign = 'left';
                        ctx.fillText(val.toFixed(1), w - padding.right + 3, Math.max(12, Math.min(h - 5, y + 3)));
                    }
                }
            },
            
            drawLooperTrendWithSetpoints: function(canvasId, dataArrays, setpoints, unit, minY, maxY) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                // Set canvas size based on container
                const container = canvas.parentElement;
                canvas.width = container.clientWidth - 16;
                canvas.height = 180;
                
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const padding = { left: 30, right: 45, top: 10, bottom: 20 };
                const chartW = w - padding.left - padding.right;
                const chartH = h - padding.top - padding.bottom;
                
                // Clear with lighter background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, w, h);
                
                // Draw grid
                ctx.strokeStyle = '#d0d7de';
                ctx.lineWidth = 1;
                
                // Horizontal grid lines
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (i / 4) * chartH;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(w - padding.right, y);
                    ctx.stroke();
                }
                
                // Y-axis labels
                ctx.fillStyle = '#57606a';
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const val = maxY - (i / 4) * (maxY - minY);
                    const y = padding.top + (i / 4) * chartH;
                    ctx.fillText(val.toFixed(0), padding.left - 4, y + 3);
                }
                
                // Draw setpoint lines for each looper (thin dashed)
                const looperColors = ['#58a6ff', '#a371f7', '#f778ba', '#db6d28', '#3fb950', '#56d4dd'];
                ctx.lineWidth = 0.5;
                ctx.setLineDash([2, 3]);
                for (let i = 0; i < 6; i++) {
                    const setpointY = padding.top + ((maxY - setpoints[i]) / (maxY - minY)) * chartH;
                    ctx.strokeStyle = looperColors[i];
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, setpointY);
                    ctx.lineTo(w - padding.right, setpointY);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);
                
                // Draw each looper line (actual values)
                for (let i = 0; i < 6; i++) {
                    const data = dataArrays[i];
                    if (!data || data.length < 2) continue;
                    
                    ctx.strokeStyle = looperColors[i];
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    
                    for (let j = 0; j < data.length; j++) {
                        const x = padding.left + (j / (this.history.maxLength - 1)) * chartW;
                        const y = padding.top + ((maxY - data[j]) / (maxY - minY)) * chartH;
                        
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Current values on right side
                ctx.font = '8px JetBrains Mono';
                for (let i = 0; i < 6; i++) {
                    const data = dataArrays[i];
                    if (data && data.length > 0) {
                        const val = data[data.length - 1];
                        const setpoint = setpoints[i];
                        const deviation = val - setpoint;
                        const y = padding.top + ((maxY - val) / (maxY - minY)) * chartH;
                        
                        // Color based on deviation from setpoint
                        ctx.fillStyle = Math.abs(deviation) > 3 ? '#f85149' : 
                                        Math.abs(deviation) > 1.5 ? '#d29922' : looperColors[i];
                        ctx.textAlign = 'left';
                        ctx.fillText(val.toFixed(1), w - padding.right + 3, Math.max(12, Math.min(h - 5, y + 3)));
                    }
                }
            },
            
            drawZoneTempTrends: function() {
                const canvas = document.getElementById('zoneTempTrendCanvas');
                if (!canvas) return;
                
                // Set canvas size based on container
                const container = canvas.parentElement;
                canvas.width = container.clientWidth - 16;
                canvas.height = 220;
                
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                const padding = { left: 40, right: 55, top: 12, bottom: 25 };
                const chartW = w - padding.left - padding.right;
                const chartH = h - padding.top - padding.bottom;
                
                // Clear with lighter background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, w, h);
                
                // Temperature range
                const minY = 800;
                const maxY = 1100;
                
                // Draw grid
                ctx.strokeStyle = '#d0d7de';
                ctx.lineWidth = 1;
                
                // Horizontal grid lines
                for (let i = 0; i <= 6; i++) {
                    const y = padding.top + (i / 6) * chartH;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(w - padding.right, y);
                    ctx.stroke();
                }
                
                // Y-axis labels
                ctx.fillStyle = '#57606a';
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 6; i++) {
                    const val = maxY - (i / 6) * (maxY - minY);
                    const y = padding.top + (i / 6) * chartH;
                    ctx.fillText(val.toFixed(0), padding.left - 4, y + 3);
                }
                
                // Zone labels and colors
                const zoneLabels = ['Entry', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7'];
                const zoneColors = ['#f0883e', '#58a6ff', '#a371f7', '#f778ba', '#db6d28', '#3fb950', '#56d4dd', '#ff7b72'];
                
                // Target temperatures (setpoints) - calculate from schedule or use defaults
                const targetTemps = [];
                targetTemps.push(this.strip.entryTemperature); // Entry
                for (let i = 0; i < 7; i++) {
                    targetTemps.push(this.schedule.temperatures?.[i + 1] || (1050 - i * 25));
                }
                
                // Draw setpoint lines (dashed)
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                for (let i = 0; i < 8; i++) {
                    const setpointY = padding.top + ((maxY - targetTemps[i]) / (maxY - minY)) * chartH;
                    if (setpointY >= padding.top && setpointY <= h - padding.bottom) {
                        ctx.strokeStyle = zoneColors[i];
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.moveTo(padding.left, setpointY);
                        ctx.lineTo(w - padding.right, setpointY);
                        ctx.stroke();
                    }
                }
                ctx.globalAlpha = 1;
                ctx.setLineDash([]);
                
                // Draw actual temperature lines
                for (let i = 0; i < 8; i++) {
                    const data = this.history.zoneTemp[i];
                    if (!data || data.length < 2) continue;
                    
                    ctx.strokeStyle = zoneColors[i];
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    
                    for (let j = 0; j < data.length; j++) {
                        const x = padding.left + (j / (this.history.maxLength - 1)) * chartW;
                        const y = padding.top + ((maxY - data[j]) / (maxY - minY)) * chartH;
                        
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Current values on right side
                ctx.font = '8px JetBrains Mono';
                ctx.textAlign = 'left';
                let lastY = -20;
                for (let i = 0; i < 8; i++) {
                    const data = this.history.zoneTemp[i];
                    if (data && data.length > 0) {
                        const val = data[data.length - 1];
                        const target = targetTemps[i];
                        const deviation = val - target;
                        let y = padding.top + ((maxY - val) / (maxY - minY)) * chartH;
                        
                        // Prevent overlapping labels
                        if (Math.abs(y - lastY) < 10) {
                            y = lastY + 10;
                        }
                        lastY = y;
                        
                        // Color based on deviation from setpoint
                        ctx.fillStyle = Math.abs(deviation) > 20 ? '#f85149' : 
                                        Math.abs(deviation) > 10 ? '#d29922' : zoneColors[i];
                        ctx.fillText(val.toFixed(0), w - padding.right + 3, Math.max(12, Math.min(h - 5, y + 3)));
                    }
                }
                
                // Update legend
                const legendEl = document.getElementById('zoneTempLegend');
                if (legendEl && legendEl.children.length === 0) {
                    for (let i = 0; i < 8; i++) {
                        const item = document.createElement('div');
                        item.style.cssText = 'display: flex; align-items: center; gap: 3px;';
                        item.innerHTML = `<div style="width: 8px; height: 3px; background: ${zoneColors[i]};"></div><span style="color: ${zoneColors[i]};">${zoneLabels[i]}</span>`;
                        legendEl.appendChild(item);
                    }
                }
            },
            
            drawMultiLineTrend: function(canvasId, dataArrays, numLines, colors, unit) {
                const canvas = this.trendCanvases[canvasId];
                const ctx = this.trendContexts[canvasId];
                if (!canvas || !ctx) return;
                
                const w = canvas.width;
                const h = canvas.height;
                const padding = { left: 40, right: 60, top: 10, bottom: 20 };
                const chartW = w - padding.left - padding.right;
                const chartH = h - padding.top - padding.bottom;
                
                // Clear
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
                
                // Find data range across all lines
                let minVal = Infinity, maxVal = -Infinity;
                let hasData = false;
                
                for (let i = 0; i < numLines; i++) {
                    const data = dataArrays[i];
                    if (data && data.length > 0) {
                        hasData = true;
                        for (let j = 0; j < data.length; j++) {
                            if (data[j] < minVal) minVal = data[j];
                            if (data[j] > maxVal) maxVal = data[j];
                        }
                    }
                }
                
                if (!hasData || minVal === Infinity) return;
                
                // Add margin
                const range = maxVal - minVal || 1;
                const margin = range * 0.1;
                minVal -= margin;
                maxVal += margin;
                const displayRange = maxVal - minVal;
                
                // Draw grid
                ctx.strokeStyle = '#21262d';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (i / 4) * chartH;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(w - padding.right, y);
                    ctx.stroke();
                }
                
                // Y-axis labels
                ctx.fillStyle = '#8b949e';
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const val = maxVal - (i / 4) * displayRange;
                    const y = padding.top + (i / 4) * chartH + 3;
                    ctx.fillText(val.toFixed(1), padding.left - 4, y);
                }
                
                // Draw each line
                const dataLen = dataArrays[0]?.length || 0;
                if (dataLen < 2) return;
                
                for (let lineIdx = 0; lineIdx < numLines; lineIdx++) {
                    const data = dataArrays[lineIdx];
                    if (!data || data.length < 2) continue;
                    
                    ctx.strokeStyle = colors[lineIdx];
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    
                    for (let i = 0; i < data.length; i++) {
                        const x = padding.left + (i / (data.length - 1)) * chartW;
                        const y = padding.top + ((maxVal - data[i]) / displayRange) * chartH;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // Current values on right side
                ctx.font = '9px JetBrains Mono';
                ctx.textAlign = 'left';
                for (let i = 0; i < numLines; i++) {
                    const data = dataArrays[i];
                    if (data && data.length > 0) {
                        const currentVal = data[data.length - 1];
                        const y = padding.top + ((maxVal - currentVal) / displayRange) * chartH;
                        
                        ctx.fillStyle = colors[i];
                        ctx.fillText(currentVal.toFixed(1), w - padding.right + 4, y + 3);
                    }
                }
            }
        };
        
        // ============================================================
        // GLOBAL FUNCTIONS
        // ============================================================
        
        // Main tab switching
        function switchMainTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.currentTarget.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById('tab-' + tabName).classList.add('active');
            
            // Resize canvas if switching to overview or trends
            if (tabName === 'overview') {
                setTimeout(() => SimulationEngine.resizeCanvas(), 50);
            }
            if (tabName === 'setup') {
                setTimeout(() => SimulationEngine.drawSchedulePreview(), 50);
            }
            if (tabName === 'trends') {
                setTimeout(() => {
                    SimulationEngine.initTrendChart();
                    SimulationEngine.drawTrendChart();
                }, 50);
            }
        }
        
        function startSimulation() {
            SimulationEngine.start();
        }
        
        function pauseSimulation() {
            SimulationEngine.pause();
        }
        
        function stopSimulation() {
            SimulationEngine.stop();
        }
        
        function resetSimulation() {
            SimulationEngine.reset();
        }
        
        function calculateSchedule() {
            console.log('Global calculateSchedule called');
            SimulationEngine.calculateSchedule();
            SimulationEngine.updateDisplay();
            // Ensure preview is drawn if we're on setup tab
            setTimeout(() => SimulationEngine.drawSchedulePreview(), 100);
        }
        
        async function calculateAndOptimizeSchedule() {
            const methodEl = document.getElementById('calcMethod');
            const objectiveEl = document.getElementById('optimObjective');
            const enableSpeedOptEl = document.getElementById('enableSpeedOpt');
            const enableSprayOptEl = document.getElementById('enableSprayOpt');
            const fdtToleranceEl = document.getElementById('fdtTolerance');
            
            const method = methodEl ? methodEl.value : 'quick';
            const objective = objectiveEl ? objectiveEl.value : 'balanced';
            
            // Update optimizer config from UI
            ScheduleOptimizer.config.enableSpeedOptimization = enableSpeedOptEl ? enableSpeedOptEl.checked : true;
            ScheduleOptimizer.config.enableSprayOptimization = enableSprayOptEl ? enableSprayOptEl.checked : true;
            ScheduleOptimizer.config.fdtTolerance = fdtToleranceEl ? parseFloat(fdtToleranceEl.value) : 3.0;
            
            console.log('Calculate Schedule - Method:', method, 'Objective:', objective);
            console.log('FDT Control - Speed:', ScheduleOptimizer.config.enableSpeedOptimization, 
                        'Spray:', ScheduleOptimizer.config.enableSprayOptimization,
                        'Tolerance:', ScheduleOptimizer.config.fdtTolerance + '¬∞C');
            
            // Quick calculation - just use existing calculateSchedule
            if (method === 'quick') {
                const statusEl = document.getElementById('optimStatus');
                const fitnessEl = document.getElementById('optimFitness');
                
                calculateSchedule();
                
                if (statusEl) {
                    statusEl.textContent = 'Quick Calc';
                    statusEl.className = 'status-card-value success';
                }
                if (fitnessEl) {
                    fitnessEl.textContent = 'N/A';
                }
                return;
            }
            
            // Optimization methods
            // Set objective weights based on selection
            switch (objective) {
                case 'quality':
                    ScheduleOptimizer.weights = {
                        thickness: 1.5, temperature: 1.2, force: 0.3, 
                        power: 0.2, flatness: 1.0, productivity: 0.2
                    };
                    break;
                case 'productivity':
                    ScheduleOptimizer.weights = {
                        thickness: 0.8, temperature: 0.6, force: 0.3,
                        power: 0.3, flatness: 0.4, productivity: 1.5
                    };
                    break;
                case 'energy':
                    ScheduleOptimizer.weights = {
                        thickness: 1.0, temperature: 0.8, force: 0.5,
                        power: 1.5, flatness: 0.4, productivity: 0.3
                    };
                    break;
                default: // balanced
                    ScheduleOptimizer.weights = {
                        thickness: 1.0, temperature: 0.8, force: 0.3,
                        power: 0.4, flatness: 0.6, productivity: 0.5
                    };
            }
            
            // Show optimizing status
            const statusEl = document.getElementById('optimStatus');
            const progressEl = document.getElementById('optimProgress');
            
            if (statusEl) {
                statusEl.textContent = 'Optimizing...';
                statusEl.className = 'status-card-value warning';
            }
            if (progressEl) {
                progressEl.parentElement.classList.add('optimizing');
                progressEl.style.width = '100%';
            }
            
            // Run optimization asynchronously
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // First calculate base schedule to get material params
            SimulationEngine.calculateSchedule();
            
            const setup = {
                material: SimulationEngine.strip.material,
                entryThickness: SimulationEngine.strip.entryThickness,
                exitThickness: SimulationEngine.strip.targetExitThickness,
                width: SimulationEngine.strip.width,
                entryTemp: SimulationEngine.strip.entryTemperature
            };
            
            console.log('Optimization setup:', setup);
            
            try {
                const result = ScheduleOptimizer.optimize(setup, method);
                console.log('Optimization result:', result);
                
                if (!result || !result.thicknesses) {
                    throw new Error('Optimization returned invalid result');
                }
                
                // Apply optimized schedule
                SimulationEngine.schedule.thicknesses = result.thicknesses;
                SimulationEngine.schedule.reductions = result.reductions;
                SimulationEngine.schedule.speeds = result.speeds;
                SimulationEngine.schedule.forces = result.forces;
                SimulationEngine.schedule.temperatures = result.temperatures;
                
                // Update stand setpoints
                for (let i = 0; i < MillConfig.numStands; i++) {
                    MillConfig.stands[i].rollGap = result.thicknesses[i + 1];
                    MillConfig.stands[i].exitH = result.thicknesses[i + 1];
                    MillConfig.stands[i].entryH = result.thicknesses[i];
                    MillConfig.stands[i].speed = result.speeds[i];
                    MillConfig.stands[i].force = result.forces[i];
                    MillConfig.stands[i].exitT = result.temperatures[i + 1];
                    MillConfig.stands[i].entryT = result.temperatures[i];
                    
                    // Calculate initial bending force for target crown
                    const targetCrowns = [30, 28, 25, 22, 20, 18, 15]; // Œºm, F1 to F7
                    const targetCrown = targetCrowns[i];
                    const standFactor = 1.0 - i * 0.08;
                    const baseThermal = 12 * standFactor;
                    const width = setup.width;
                    const forceCrown = -0.025 * result.forces[i] * Math.pow(width / 1000, 2);
                    const requiredBendingCrown = targetCrown - baseThermal - forceCrown;
                    const requiredBending = requiredBendingCrown / (0.008 * Math.pow(width / 1000, 2));
                    // Start at 100% - let controller fine-tune
                    MillConfig.stands[i].bendingForce = Math.max(-1500, Math.min(1500, requiredBending));
                    MillConfig.stands[i].cvcShift = 5; // Start with small positive CVC
                    MillConfig.stands[i].thermalCrown = 0;
                    MillConfig.stands[i].crownIntegral = 0;
                }
                
                // Update cooling settings
                const mat = MaterialDatabase.grades[setup.material];
                const targetFDT = mat ? (mat.targetFDT.min + mat.targetFDT.max) / 2 : 880;
                const spraySettings = ScheduleOptimizer.optimizeCooling(
                    result, targetFDT, setup.material, setup.width
                );
                
                for (let i = 0; i < spraySettings.length && i < CoolingSystem.sprays.length; i++) {
                    CoolingSystem.sprays[i].flowSetpoint = spraySettings[i];
                }
                
                // Update UI
                SimulationEngine.updateScheduleDisplay();
                SimulationEngine.createCoolingZones();
                SimulationEngine.updateDisplay();
                setTimeout(() => SimulationEngine.drawSchedulePreview(), 100);
                
                // Show success
                const fitnessEl = document.getElementById('optimFitness');
                const statusEl2 = document.getElementById('optimStatus');
                const f7SpeedEl = document.getElementById('f7SpeedDisplay');
                const avgSprayEl = document.getElementById('avgSprayFlow');
                
                if (fitnessEl && result.fitness !== undefined) {
                    fitnessEl.textContent = result.fitness.toFixed(2);
                }
                
                // Display F7 speed
                if (f7SpeedEl && result.speeds && result.speeds.length >= 7) {
                    const f7Speed = result.speeds[6];
                    f7SpeedEl.textContent = f7Speed.toFixed(2) + ' m/s';
                    // Color based on speed range
                    if (f7Speed < ScheduleOptimizer.constraints.minSpeed + 1) {
                        f7SpeedEl.className = 'status-card-value warning';
                    } else if (f7Speed > ScheduleOptimizer.constraints.maxSpeed - 2) {
                        f7SpeedEl.className = 'status-card-value warning';
                    } else {
                        f7SpeedEl.className = 'status-card-value success';
                    }
                }
                
                // Display average spray flow
                if (avgSprayEl) {
                    let avgFlow = 0;
                    if (result.sprayFlows && result.sprayFlows.length > 0) {
                        avgFlow = result.sprayFlows.reduce((a, b) => a + b, 0) / result.sprayFlows.length;
                    } else {
                        // Calculate from CoolingSystem
                        let totalFlow = 0;
                        for (let i = 0; i < CoolingSystem.sprays.length; i++) {
                            totalFlow += CoolingSystem.sprays[i].flowSetpoint;
                        }
                        avgFlow = totalFlow / CoolingSystem.sprays.length;
                    }
                    avgSprayEl.textContent = avgFlow.toFixed(0) + '%';
                    // Color based on extremes
                    if (avgFlow < 10 || avgFlow > 90) {
                        avgSprayEl.className = 'status-card-value warning';
                    } else {
                        avgSprayEl.className = 'status-card-value success';
                    }
                }
                
                if (statusEl2) {
                    if (result.valid) {
                        statusEl2.textContent = 'Optimized';
                        statusEl2.className = 'status-card-value success';
                        statusEl2.title = 'All constraints satisfied';
                    } else {
                        statusEl2.textContent = 'Constraints!';
                        statusEl2.className = 'status-card-value warning';
                        // Show violations in tooltip and console
                        const violationText = result.violations ? result.violations.join('\n') : 'Unknown constraint violation';
                        statusEl2.title = 'Click for details:\n' + violationText;
                        console.warn('=== OPTIMIZATION COMPLETED WITH CONSTRAINT VIOLATIONS ===');
                        if (result.violations) {
                            result.violations.forEach(v => console.warn('  ‚ö† ' + v));
                        }
                        // Also show alert with first few violations
                        if (result.violations && result.violations.length > 0) {
                            const shortList = result.violations.slice(0, 5).join('\n‚Ä¢ ');
                            const moreText = result.violations.length > 5 ? `\n... and ${result.violations.length - 5} more (see console)` : '';
                            console.info('Constraint violations:\n‚Ä¢ ' + shortList + moreText);
                        }
                    }
                }
                
                console.log('Schedule optimization applied successfully');
                
            } catch (error) {
                console.error('Optimization failed:', error);
                console.error('Error stack:', error.stack);
                
                const statusEl2 = document.getElementById('optimStatus');
                if (statusEl2) {
                    statusEl2.textContent = 'Failed';
                    statusEl2.className = 'status-card-value danger';
                }
            }
            
            if (progressEl) {
                progressEl.parentElement.classList.remove('optimizing');
                progressEl.style.width = '0%';
            }
        }
        
        // Keep runOptimization for backwards compatibility
        async function runOptimization() {
            // Redirect to new combined function with hybrid method
            document.getElementById('calcMethod').value = 'hybrid';
            await calculateAndOptimizeSchedule();
        }
        
        function updateMaterialParams() {
            const steelType = document.getElementById('steelType').value;
            const gradeSelect = document.getElementById('steelGrade');
            
            // Update grade options based on steel type
            if (steelType === 'GO') {
                gradeSelect.innerHTML = `
                    <optgroup label="Grain-Oriented Normal">
                        <option value="GO_Normal">GO Normal (Si: 3.0%)</option>
                    </optgroup>
                    <optgroup label="Grain-Oriented High">
                        <option value="GO_High">GO High (Si: 3.2%)</option>
                    </optgroup>
                    <optgroup label="Grain-Oriented Premium">
                        <option value="GO_Premium">GO Premium (Si: 3.4%)</option>
                    </optgroup>
                `;
            } else {
                gradeSelect.innerHTML = `
                    <optgroup label="Non-Oriented Normal">
                        <option value="50W800">50W800 (Si: 0.5%)</option>
                        <option value="50W600">50W600 (Si: 1.0%)</option>
                        <option value="50W470">50W470 (Si: 1.5%)</option>
                    </optgroup>
                    <optgroup label="Non-Oriented High">
                        <option value="35W360">35W360 (Si: 2.0%)</option>
                        <option value="35W300">35W300 (Si: 2.5%)</option>
                        <option value="35W270">35W270 (Si: 2.8%)</option>
                    </optgroup>
                    <optgroup label="Non-Oriented Premium">
                        <option value="30W250">30W250 (Si: 3.0%)</option>
                        <option value="27W230">27W230 (Si: 3.2%)</option>
                        <option value="23W200">23W200 (Si: 3.5%)</option>
                    </optgroup>
                `;
            }
            
            calculateSchedule();
        }
        
        function setView(view) {
            SimulationEngine.currentView = view;
            
            document.querySelectorAll('.tabs .tab').forEach(tab => {
                tab.classList.toggle('active', tab.textContent.toLowerCase() === view);
            });
            
            SimulationEngine.drawCanvas();
        }
        
        // Note: Individual stand control sliders removed - all stands now displayed in tables
        
        function updateTrendChart() {
            SimulationEngine.drawTrendChart();
        }
        
        function updateSprayFlow(index, value) {
            const flowValue = parseFloat(value);
            CoolingSystem.sprays[index].flowSetpoint = flowValue;
            CoolingSystem.sprays[index].actualFlow = flowValue; // Immediate effect
            document.getElementById(`sprayValue${index}`).textContent = value + '%';
        }
        
        function optimizeCooling() {
            const mat = MaterialDatabase.grades[SimulationEngine.strip.material];
            const targetFDT = mat ? (mat.targetFDT.min + mat.targetFDT.max) / 2 : 880;
            
            const spraySettings = ScheduleOptimizer.optimizeCooling(
                SimulationEngine.schedule,
                targetFDT,
                SimulationEngine.strip.material,
                SimulationEngine.strip.width
            );
            
            // Apply optimized settings
            for (let i = 0; i < spraySettings.length; i++) {
                CoolingSystem.sprays[i].flowSetpoint = spraySettings[i];
                document.getElementById(`spraySlider${i}`).value = spraySettings[i];
                document.getElementById(`sprayValue${i}`).textContent = spraySettings[i].toFixed(0) + '%';
            }
        }
        
        function closeModal() {
            document.getElementById('standModal').classList.remove('active');
        }
        
        function exportData() {
            const data = {
                metadata: {
                    exportTime: new Date().toISOString(),
                    simulatorVersion: '2.0',
                    material: SimulationEngine.strip.material,
                    steelType: document.getElementById('steelType').value
                },
                setup: {
                    entryThickness: SimulationEngine.strip.entryThickness,
                    targetExitThickness: SimulationEngine.strip.targetExitThickness,
                    width: SimulationEngine.strip.width,
                    entryTemperature: SimulationEngine.strip.entryTemperature
                },
                schedule: SimulationEngine.schedule,
                standConfig: MillConfig.stands.map(s => ({
                    name: s.name,
                    workRollDia: s.workRollDia,
                    millModulus: s.millModulus,
                    rollGap: s.rollGap,
                    bendingForce: s.bendingForce,
                    cvcShift: s.cvcShift,
                    speed: s.speed,
                    force: s.force,
                    exitH: s.exitH,
                    exitT: s.exitT
                })),
                looperConfig: MillConfig.loopers.map(l => ({
                    name: l.name,
                    angleSetpoint: l.angleSetpoint,
                    tensionSetpoint: l.tensionSetpoint,
                    angle: l.angle,
                    tension: l.tension
                })),
                coolingConfig: CoolingSystem.sprays.map(s => ({
                    name: s.name,
                    enabled: s.enabled,
                    flowSetpoint: s.flowSetpoint,
                    actualFlow: s.actualFlow,
                    pattern: s.pattern,
                    waterFlow: s.waterFlow,
                    heatRemoved: s.heatRemoved,
                    tempDrop: s.tempDrop
                })),
                optimization: {
                    method: ScheduleOptimizer.bestSolution?.method || 'none',
                    fitness: ScheduleOptimizer.bestFitness,
                    weights: ScheduleOptimizer.weights,
                    constraints: ScheduleOptimizer.constraints,
                    history: ScheduleOptimizer.history
                },
                results: {
                    exitThickness: SimulationEngine.strip.currentThickness,
                    exitTemperature: SimulationEngine.strip.currentTemperature,
                    processedLength: SimulationEngine.strip.position,
                    simTime: SimulationEngine.simTime
                },
                history: SimulationEngine.history
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `fm_sim_export_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            SimulationEngine.init();
            
            // ISC Auto mode handler - enable/disable sliders based on mode
            const iscAutoCheckbox = document.getElementById('iscAuto');
            const updateSliderState = () => {
                const isAuto = iscAutoCheckbox.checked;
                for (let i = 0; i < 6; i++) {
                    const slider = document.getElementById(`spraySlider${i}`);
                    if (slider) {
                        slider.disabled = isAuto;
                        slider.style.opacity = isAuto ? '0.5' : '1';
                        slider.style.cursor = isAuto ? 'not-allowed' : 'pointer';
                    }
                }
                // Reset PID state when switching modes
                resetISCAutoState();
            };
            
            iscAutoCheckbox.addEventListener('change', updateSliderState);
            // Initial state
            updateSliderState();
        });
        
        // Reset ISC Auto state (called when toggling auto mode)
        function resetISCAutoState() {
            // Reset cascade control state
            SimulationEngine.cascadeState = {
                iscIntegral: 0,
                iscFilteredError: 0,
                iscBaseFlow: 50,
                speedIntegral: 0,
                speedFilteredError: 0,
                speedMultiplier: 1.0,
                iscSaturated: false
            };
        }
    </script>
</body>
</html>
